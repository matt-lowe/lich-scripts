=begin

	This script waits for you to kill something, and then it skins (optional),
	searches, and picks up loot.

	;loot help

	 author: Tillmen (tillmen@lichproject.org)
	   game: Gemstone
	   tags: loot
	version: 0.25

	changelog:
      0.25 (2018-08-23):
         add a message for skin failure due to lack of blunt weapon
		0.24 (2018-08-20):
			fix bug with safe-kneel (Tysong)
		0.23 (2017-10-08):
			add category of monster that is skinnable by both edged and blunt weapons: use blunt weapons when available

=end
=begin

		0.22 (2017-10-01):
			start using exclude setting on Confluence drops
		0.21 (2017-01-14):
			recognized delayed acid (904) kills
		0.20 (2016-09-17):
			add option to not use your disk
		0.19 (2016-05-05):
			add another message to recognize Maelstrom
		0.18 (2015-07-22):
			add support for Pestilence (716)
		0.17 (2015-07-11):
			make sure $loot_working gets set to false if the script is killed
		0.16 (2015-06-04):
			add support for climatewear
		0.15 (2015-04-27):
			make various settings take effect when changed while the script is running
		0.14 (2014-04-02):
			pick up alchemy reagents in the Elemental Confluence
		0.13 (2015-04-01):
			recognize spirit slayer kills
		0.12 (2015-04-01):
			pick up gems in the Elemental Confluence
		0.11 (2015-03-30):
			fix for picking up things knocked out of a monster's hands
		0.10 (2015-02-01):
			fix bug when setting skinweapon and bluntskinweapons
		0.9 (2015-01-31):
			add new loot type (valuable) to default settings
		0.8 (2015-01-28):
			don't evaluate 740 as an attack (basically freezes when the room is completely full)
		0.7 (2015-01-22):
			added ignore-creatures option (Calael)
			added option to stow herbs in herbsack
			don't phase enruned and mithril boxes
			recognize sorcerer sacrifice deaths
			change sack settings using this script instead of ;settings or ;vars
			pick up things that creatures drop even if the attack that causes the drop doesn't kill them
		0.6 (2014-12-05):
			make safe-kneel ignore passive npcs
		0.5 (2014-11-26):
			fix safe-kneel option
		0.4 (2014-11-10):
			added support for a scripted container
		0.3 (2014-10-01):
			don't loot infernal liches

=end

# todo: setting for items to loot, rather than items to exlude

if defined?(GameObj.type_data)
	GameObj.load_data if GameObj.type_data.empty? or GameObj.type_data.nil?
	if GameObj.type_data.nil?
		wait_while { running?('repository') }
		start_script 'repository', [ 'download', 'gameobj-data.xml' ]
		wait_while { running?('repository') }
		GameObj.load_data
		exit if GameObj.type_data.nil?
	end
end

$loot_settings = char_settings = CharSettings.to_hash

Settings['unskinnable']          = Array.new if Settings['unskinnable'].nil?
Settings['blunt-skinnable']      = Array.new if Settings['blunt-skinnable'].nil?
Settings['free-hand-skinnable']  = Array.new if Settings['free-hand-skinnable'].nil?
CharSettings['skin']             = true      if CharSettings['skin'].nil?
CharSettings['604']              = false     if CharSettings['604'].nil?
CharSettings['safe-kneel']       = false     if CharSettings['safe-kneel'].nil?
CharSettings['kneel']            = false     if CharSettings['kneel'].nil?
CharSettings['stance']           = false     if CharSettings['stance'].nil?
CharSettings['empty']            = false     if CharSettings['empty'].nil?
CharSettings['never-empty']      = false     if CharSettings['never-empty'].nil?
CharSettings['phase-boxes']      = false     if CharSettings['phase-boxes'].nil?
CharSettings['disk-boxes']       = true      if CharSettings['disk-boxes'].nil?
CharSettings['get-arrows']       = false     if CharSettings['get-arrows'].nil?
CharSettings['eblade-arrows']    = false     if CharSettings['eblade-arrows'].nil?
CharSettings['use-ambrominas']   = true      if CharSettings['use-ambrominas'].nil?
CharSettings['ignore-creatures'] = 'ice golem|fire elemental|skayl|lava golem|mein golem|mein android|infernal lich|frostborne lich' if CharSettings['ignore-creatures'].nil?
CharSettings['loot-types']       = 'gem|skin|reagent|herb|jewelry|valuable|magic|scroll|wand|uncommon|box' if CharSettings['loot-types'].nil?

likely_bundle_id_list   = Hash.new
injures_on_skin_regex   = /^(?:myklian)$/
injures_on_search_regex = /^(?:myklian|magru|glacei)$/
free_hand_search_regex  = /^(?:glacei)$/
put_regex               = /^You (?:attempt to shield .*? from view as you |discreetly |carefully |absent-mindedly )?(?:put|place|slip|tuck|add|hang|drop|untie your|find an incomplete bundle|wipe off .*? and sheathe)|^A sigh of grateful pleasure can be heard as you feed .*? to your|^As you place|^I could not find what you were referring to\.$|^Your bundle would be too large|^The .+ is too large to be bundled\.|^As you place your|^The .*? is already a bundle|^Your .*? won't fit in .*?\.$|^You can't .+ It's closed!$|^You need a free hand to pick that up\./
get_regex               = /^You (?:shield the opening of .*? from view as you |discreetly |carefully |deftly )?(?:remove|draw|grab|reach|slip|tuck|retrieve|already have|unsheathe|pick up)|^Get what\?$|^Why don't you leave some for others\?$|^You need a free hand|^I could not find what you were referring to\./
skinweapon              = nil
skinweaponsack          = nil
bluntskinweapon         = nil
bluntskinweaponsack     = nil
both_skinnable          = [ 'stone mastiff' ] # can be skinned with both edged or blunt: use blunt if available
script_name             = script.name
lootsack_list           = Array.new
herbsack                = nil
arrowsack               = nil
$loot_working           = false

show_settings = proc {
	fix_setting = { true => 'on', false => 'off' }
	output = String.new
	output.concat "skin:             #{fix_setting[char_settings['skin']]}\n"
	output.concat "604:              #{fix_setting[char_settings['604']]}\n"
	output.concat "kneel:            #{fix_setting[char_settings['kneel']]}\n"
	output.concat "safe-kneel:       #{fix_setting[char_settings['safe-kneel']]}\n"
	output.concat "stance:           #{fix_setting[char_settings['stance']]}\n"
	output.concat "empty:            #{fix_setting[char_settings['empty']]}\n"
	output.concat "never-empty:      #{fix_setting[char_settings['never-empty']]}\n"
	output.concat "phase-boxes:      #{fix_setting[char_settings['phase-boxes']]}\n"
	output.concat "disk-boxes:       #{fix_setting[char_settings['disk-boxes']]}\n"
	output.concat "get-arrows:       #{fix_setting[char_settings['get-arrows']]}\n"
	output.concat "eblade-arrows:    #{fix_setting[char_settings['eblade-arrows']]}\n"
	output.concat "use-ambrominas:   #{fix_setting[char_settings['use-ambrominas']]}\n"
	output.concat "ignore-creatures: #{char_settings['ignore-creatures']}\n"
	output.concat "exclude:          #{char_settings['exclude']}\n"
	output.concat "loot-types:       #{char_settings['loot-types']}\n"
	output.concat "\n"
	output.concat "lootsack:            #{UserVars.lootsack}\n"
	lootsack_num = 2
	while (UserVars.send("lootsack#{lootsack_num}").class == String) and not UserVars.send("lootsack#{lootsack_num}").empty?
		output.concat "lootsack#{lootsack_num}:           #{UserVars.send("lootsack#{lootsack_num}")}\n"
		lootsack_num += 1
	end
	output.concat "skinweapon:          #{UserVars.skinweapon}\n"
	output.concat "skinweaponsack:      #{UserVars.skinweaponsack}\n"
	output.concat "bluntskinweapon:     #{UserVars.bluntskinweapon}\n"
	output.concat "bluntskinweaponsack: #{UserVars.bluntskinweaponsack}\n"
	output.concat "arrowsack:           #{UserVars.arrowsack}\n"
	output.concat "herbsack:            #{UserVars.herbsack}\n"
	respond output
}

show_help = proc {
	spacing = ''.ljust($lich_char.length + script.name.length, ' ')
	output = "\n"
	output.concat "#{$lich_char}#{script.name}                          waits for you to kill someting and loots it\n"
	output.concat "#{$lich_char}#{script.name} skin=<on/off>            skins before looting\n"
	output.concat "#{$lich_char}#{script.name} 604=<on/off>             cast 604 before skinning\n"
	output.concat "#{$lich_char}#{script.name} kneel=<on/off>           always kneels to skin\n"
	output.concat "#{$lich_char}#{script.name} safe-kneel=<on/off>      kneels to skin if no live npcs are in the room\n"
	output.concat "#{$lich_char}#{script.name} stance=<on/off>          changes to offensive stance to skin\n"
	output.concat "#{$lich_char}#{script.name} empty=<on/off>           empty left hand when skinning\n"
	output.concat "#{$lich_char}#{script.name} never-empty=<on/off>     empty hand preference is ignored for critters that\n"
	output.concat "#{spacing                 }                          cannot be skinned without an empty hand; use this\n"
	output.concat "#{spacing                 }                          setting to skip those critters\n"
	output.concat "#{$lich_char}#{script.name} phase-boxes=<on/off>     make boxes lighter\n"
	output.concat "#{$lich_char}#{script.name} disk-boxes=<on/off>      put boxes in your disk\n"
	output.concat "#{$lich_char}#{script.name} get-arrows=<on/off>      pick up the arrows you fire and put them in your\n"
	output.concat "#{spacing                 }                          arrowsack (or lootsack if arrowsack isn't set)\n"
	output.concat "#{$lich_char}#{script.name} eblade-arrows=<on/off>   eblade arrows when they fail to bundle\n"
	output.concat "#{$lich_char}#{script.name} use-ambrominas=<on/off>  eat ambrominas leaf after skinning or searching\n"
	output.concat "#{spacing                 }                          something that causes injury\n"
	output.concat "#{$lich_char}#{script.name} stow-herbs=<on/off>      put herbs in your herbsack\n"
	output.concat "#{$lich_char}#{script.name} ignore-creatures=<regex> regex of creatures not to loot automatically\n"
	output.concat "#{$lich_char}#{script.name} ignore-creatures=nil     clear ignore-creatures setting\n"
	output.concat "#{$lich_char}#{script.name} exclude=<regex>          regex of items not to pick up\n"
	output.concat "#{$lich_char}#{script.name} exclude=nil              clear exclude setting\n"
	output.concat "#{$lich_char}#{script.name} loot-types=<regex>       regex of the types of items to pick up\n"
	output.concat "#{$lich_char}#{script.name} loot-types=nil           reset loot types to the default\n"
	output.concat "\n"
	output.concat "#{$lich_char}#{script.name} lootsack=<container>\n"
	output.concat "#{$lich_char}#{script.name} lootsack2=<container>\n"
	output.concat "#{$lich_char}#{script.name} lootsack<num>=<container>\n"
	output.concat "#{$lich_char}#{script.name} skinweapon=<weapon>\n"
	output.concat "#{$lich_char}#{script.name} skinweaponsack=<container>\n"
	output.concat "#{$lich_char}#{script.name} bluntskinweapon=<weapon>\n"
	output.concat "#{$lich_char}#{script.name} bluntskinweaponsack=<container>\n"
	output.concat "#{$lich_char}#{script.name} arrowsack=<container>\n"
	output.concat "#{$lich_char}#{script.name} herbsack=<container>\n"
	output.concat "\n"
	respond output
}

find_lootsacks = proc {
	lootsack_list = Array.new
	lootsack_num = nil
	while (UserVars.send("lootsack#{lootsack_num}").class == String) and not UserVars.send("lootsack#{lootsack_num}").empty?
		if lootsack = GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.send("lootsack#{lootsack_num}").strip)}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.send("lootsack#{lootsack_num}")).sub(' ', ' .*')}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.send("lootsack#{lootsack_num}")).sub(' ', ' .*')}/i }
			lootsack_list.push(lootsack)
		else
			respond "[#{script_name}: warning: failed to find lootsack#{lootsack_num} (#{UserVars.send("lootsack#{lootsack_num}")})]"
		end
		lootsack_num = 1 if lootsack_num.nil?
		lootsack_num += 1
	end
}

find_skinning_equipment = proc {
	if (UserVars.skinweaponsack.nil? or UserVars.skinweaponsack.empty?)
		respond "[#{script_name}: warning: skinning is enabled, but skinweaponsack is not set.  (;#{script.name} skinweaponsack=<container name>)]"
		skinweaponsack = nil
		skinweapon = nil
	elsif(UserVars.skinweapon.nil? or UserVars.skinweapon.empty?)
		respond "[#{script_name}: warning: skinning is enabled, but skinweapon is not set.  (;#{script.name} skinweapon=<weapon name>)]"
		skinweaponsack = nil
		skinweapon = nil
	else
		unless skinweaponsack = GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweaponsack.strip)}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweaponsack).sub(' ', ' .*')}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweaponsack).sub(' ', ' .*')}/i }
			dothistimeout "pull my #{UserVars.skinweaponsack}", 10, /^You pull|^You reach|^I'm afraid|^What were you referring to/
			dothistimeout "inventory", 10, /^You are wearing/
			if skinweaponsack = GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweaponsack.strip)}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweaponsack).sub(' ', ' .*')}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweaponsack).sub(' ', ' .*')}/i }
				dothistimeout "push ##{skinweaponsack.id}", 10, /^You push|^You reach/
			end
		end
		if not skinweaponsack
			respond "[#{script_name}: warning: failed to find your skinweaponsack]"
			skinweaponsack = nil
			skinweapon = nil
		else
			if skinweaponsack.contents.nil?
				dothistimeout "look in ##{skinweaponsack.id}", 10, /^In the/
			end
			unless skinweapon = (skinweaponsack.contents | [ GameObj.right_hand, GameObj.left_hand ] | GameObj.containers.values.flatten).find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweapon.strip)}$/i } || ([ GameObj.right_hand, GameObj.left_hand ] | GameObj.containers.values.flatten).find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweapon).sub(' ', ' .*')}$/i } || (skinweaponsack.contents | [ GameObj.right_hand, GameObj.left_hand ] | GameObj.containers.values.flatten).find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweapon).sub(' ', ' .*')}/i }
				respond "[#{script_name}: warning: failed to find your skinweapon]"
				skinweaponsack = nil
				skinweapon = nil
			end
		end
	end
	if UserVars.bluntskinweaponsack and UserVars.bluntskinweapon
		if bluntskinweaponsack = GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.bluntskinweaponsack.strip)}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.bluntskinweaponsack).sub(' ', ' .*')}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.bluntskinweaponsack).sub(' ', ' .*')}/i }
			if bluntskinweaponsack.contents.nil?
				dothistimeout "look in ##{bluntskinweaponsack.id}", 10, /^In the/
			end
			unless bluntskinweapon = ([ GameObj.right_hand, GameObj.left_hand ] | GameObj.containers.values.flatten).find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.bluntskinweapon.strip)}$/i } || ([ GameObj.right_hand, GameObj.left_hand ] | GameObj.containers.values.flatten).find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.bluntskinweapon).sub(' ', ' .*')}$/i } || ([ GameObj.right_hand, GameObj.left_hand ] | GameObj.containers.values.flatten).find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.bluntskinweapon).sub(' ', ' .*')}/i }
				respond "[#{script_name}: warning: failed to find your bluntskinweapon: #{UserVars.bluntskinweapon}]"
				bluntskinweaponsack = nil
				bluntskinweapon = nil
			end
		else
			respond "[#{script_name}: warning: failed to find your bluntskinweaponsack: #{UserVars.bluntskinweaponsack}]"
			bluntskinweaponsack = nil
			bluntskinweapon = nil
		end
	else
		bluntskinweaponsack = nil
		bluntskinweapon = nil
	end
}

find_herbsack = proc {
	if UserVars.herbsack.nil? or UserVars.herbsack.empty?
		if CharSettings['stow-herbs']
			respond "[#{script_name}: warning: stow-herbs option is on, but herbsack is not set]"
		elsif CharSettings['use-ambrominas']
			respond "[#{script_name}: warning: use-ambrominas option is on, but herbsack is not set]"
		end
	else
		unless herbsack = (GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.herbsack.strip)}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.herbsack).sub(' ', ' .*')}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.herbsack).sub(' ', ' .*')}/i } || false)
			respond "[#{script_name}: warning: failed to find your herbsack]"
		end
	end
}

find_arrowsack = proc {
	if UserVars.arrowsack.nil? or UserVars.arrowsack.empty?
		arrowsack = lootsack_list[0]
	else
		unless arrowsack = GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.arrowsack.strip)}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.arrowsack).sub(' ', ' .*')}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.arrowsack).sub(' ', ' .*')}/i }
			respond "[#{script_name}: warning: failed to find your arrowsack]"
		end
	end
}

if script.vars.empty?
	nil
elsif script.vars[0].downcase == 'list'
	show_settings.call
	exit
elsif script.vars[0] =~ /^(skin|604|kneel|safe\-kneel|stance|empty|never\-empty|phase\-boxes|disk\-boxes|get\-arrows|eblade\-arrows|use\-ambrominas|stow\-herbs)=(on|off|yes|no|true|false)$/i
	fix_setting = { 'on' => true, 'yes' => true, 'true' => true, 'off' => false, 'no' => false, 'false' => false }
	CharSettings[$1.downcase] = fix_setting[$2.downcase]
	echo 'setting saved'
	exit
elsif script.vars[0] =~ /^(skinweapon|bluntskinweapon)=(.*)$/i
	var = $1
	name = $2.strip
	if name == 'nil'
		UserVars.send("#{var}=", nil)
		echo 'setting cleared'
	else
		UserVars.send("#{var}=", name)
		echo 'setting saved'
	end
	exit
elsif script.vars[0] =~ /^(lootsack\d*|skinweaponsack|bluntskinweaponsack|arrowsack|herbsack)=(.*)$/i
	var = $1
	name = $2.strip
	if name == 'nil'
		UserVars.send("#{var}=", nil)
		echo 'setting cleared'
	else
		obj_list = GameObj.inv.find_all { |obj| obj.noun == name }
		if obj_list.empty?
			obj_list = GameObj.inv.find_all { |obj| obj.name == name }
		end
		if obj_list.empty?
			obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{Regexp.escape(name)}$/i }
		end
		if obj_list.empty?
			obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{name.split(' ').collect { |n| Regexp.escape(n) }.join(".*\\b")}/i }
		end
		if obj_list.empty?
			echo "error: failed to find a container in your inventory by the name of \"#{name}\""
		elsif obj_list.length > 1
			echo "error: multiple containers in your inventory match the name \"#{name}\""
		else
			UserVars.send("#{var}=", name)
			echo 'setting saved'
		end
	end
	exit
elsif script.vars[0] =~ /^ignore-creatures=(.*)$/i
	if $1 == 'nil'
		CharSettings['ignore-creatures'] = false
		echo 'setting cleared'
	else
		CharSettings['ignore-creatures'] = $1
		echo 'setting saved'
	end
	exit
elsif script.vars[0] =~ /^exclude=(.*)$/i
	if $1 == 'nil'
		CharSettings['exclude'] = nil
		echo 'setting cleared'
	else
		CharSettings['exclude'] = $1
		echo 'setting saved'
	end
	exit
elsif script.vars[0] =~ /^loot\-?types=(.*)$/i
	if $1 == 'nil'
		CharSettings['loot-types'] = 'gem|skin|reagent|herb|jewelry|valuable|magic|scroll|wand|uncommon|box'
		echo 'setting reset'
	else
		CharSettings['loot-types'] = $1
		echo 'setting saved'
	end
	exit
else
	show_help.call
	exit
end

status_tags
silence_me

find_lootsacks.call

if lootsack_list.empty?
	echo 'error: no lootsacks found'
	exit
end

if CharSettings['skin']
	find_skinning_equipment.call
end

if CharSettings['stow-herbs'] or CharSettings['use-ambrominas']
	find_herbsack.call
end

if CharSettings['get-arrows']
	find_arrowsack.call
end

before_dying { DownstreamHook.remove 'loot-watch-sack' }
original_lootsack_list = lootsack_list.dup
watch_lootsack = proc {
	unless DownstreamHook.list.include?('loot-watch-sack')
		remove_count = 0
		hook_proc = proc { |server_string|
			if server_string =~ /^<clearContainer.*You (?:deftly )?remove .* from .* exist="#{original_lootsack_list.first.id}"/
				remove_count += 1
				if remove_count > 2
					DownstreamHook.remove('loot-watch-sack')
					lootsack_list = original_lootsack_list.dup
				end
			elsif server_string =~ /^<clearContainer.*You put .* in .* exist="#{original_lootsack_list.first.id}"/
				remove_count -= 1
			end
			server_string
		}
		DownstreamHook.add('loot-watch-sack', hook_proc)
	end
}

script_name = script.name.dup
hook_proc = proc { |client_string|
	begin
		if client_string =~ /^(?:<c>)?#{$lich_char}#{script_name}\s+(.*)$/
			cmd = $1
			if cmd.downcase == 'list'
				show_settings.call
				nil
			elsif cmd =~ /^(skin|604|kneel|safe\-kneel|stance|empty|never\-empty|phase\-boxes|disk\-boxes|get\-arrows|eblade\-arrows|use\-ambrominas|stow\-herbs)=(on|off|yes|no|true|false)$/i
				fix_setting = { 'on' => true, 'yes' => true, 'true' => true, 'off' => false, 'no' => false, 'false' => false }
				opt = $1
				value = fix_setting[$2.downcase]
				char_settings[opt] = value
				respond "[#{script_name}: setting saved]"
				if (opt == 'skin') and (value == true)
					find_skinning_equipment.call
				elsif (opt == 'get-arrows') and (value == true)
					find_arrowsack.call
				elsif ((opt == 'stow-herbs') or (opt == 'use-ambrominas')) and (value == true)
					find_herbsack.call
				end
				nil
			elsif cmd =~ /^(skinweapon|bluntskinweapon)=(.*)$/i
				var = $1
				name = $2.strip
				if name == 'nil'
					UserVars.send("#{var}=", nil)
					respond '[loot: setting cleared]'
				else
					UserVars.send("#{var}=", name)
					respond '[loot: setting saved]'
				end
				find_skinning_equipment.call
				nil
			elsif cmd =~ /^(lootsack\d*|skinweaponsack|bluntskinweaponsack|arrowsack|herbsack)=(.*)$/i
				var = $1
				name = $2.strip
				if name == 'nil'
					UserVars.send("#{var}=", nil)
					respond '[loot: setting cleared]'
				else
					obj_list = GameObj.inv.find_all { |obj| obj.noun == name }
					if obj_list.empty?
						obj_list = GameObj.inv.find_all { |obj| obj.name == name }
					end
					if obj_list.empty?
						obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{Regexp.escape(name)}$/i }
					end
					if obj_list.empty?
						obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{name.split(' ').collect { |n| Regexp.escape(n) }.join(".*\\b")}/i }
					end
					if obj_list.empty?
						respond "[loot: error: failed to find a container in your inventory by the name of \"#{name}\"]"
					elsif obj_list.length > 1
						respond "[loot: error: multiple containers in your inventory match the name \"#{name}\"]"
					else
						UserVars.send("#{var}=", name)
						respond '[loot: setting saved]'
						if var =~ /^(?:blunt)?skinweaponsack$/
							find_skinning_equipment.call
						elsif var =~ /^lootsack\d*$/
							find_lootsacks.call
						elsif var == 'herbsack'
							find_herbsack.call
						elsif var == 'arrowsack'
							find_arrowsack.call
						end
					end
				end
				nil
			elsif cmd =~ /^ignore-creatures=(.*)$/i
				if $1 == 'nil'
					char_settings['ignore-creatures'] = nil
					respond "[#{script_name}: setting cleared]"
				else
					char_settings['ignore-creatures'] = $1
					respond "[#{script_name}: setting saved]"
				end
				$loot_ignore_creatures = char_settings['ignore-creatures']
				nil
			elsif cmd =~ /^exclude=(.*)$/i
				if $1 == 'nil'
					char_settings['exclude'] = nil
					respond "[#{script_name}: setting cleared]"
				else
					char_settings['exclude'] = $1
					respond "[#{script_name}: setting saved]"
				end
				nil
			elsif cmd =~ /^loot\-?types=(.*)$/i
				if $1 == 'nil'
					char_settings['loot-types'] = 'gem|reagent|herb|jewelry|magic|scroll|wand|uncommon|box'
					respond "[#{script_name}: setting reset]"
				else
					char_settings['loot-types'] = $1
					respond "[#{script_name}: setting saved]"
				end
				nil
			else
				show_help.call
				nil
			end
		else
			client_string
		end
	rescue
		UpstreamHook.remove(script_name)
		client_string
	end
}
before_dying { UpstreamHook.remove(script_name) }
UpstreamHook.add(script_name, hook_proc)

$loot_ignore_creatures = CharSettings['ignore-creatures']

$loot_dead_npcs  = Array.new
$loot_grab_list  = Array.new
$loot_working    = false
$loot_berserking = false

$loot_stats ||= Hash.new
$loot_stats['start_time']       ||= Time.now
$loot_stats['kills']            ||= 0
$loot_stats['successful_skins'] ||= 0
$loot_stats['failed_skins']     ||= 0
$loot_stats['loot_count']       ||= 0
$loot_arrow_ids                 ||= LimitedArray.new
$loot_arrow_wait                  = Array.new
$loot_needs_eblade              ||= Array.new
$loot_search_rooms              ||= Array.new
failed_drag_lootsack              = Hash.new
need_close_lootsack               = Array.new

can_drag = true

exec_string = "
	hide_me
	status_tags
	before_dying { kill_script(#{script.name.inspect}) if running?(#{script.name.inspect}) }
	Thread.new { wait_while { running?(#{Script.self.name.inspect}) }; Script.self.kill }
	immolated = LimitedArray.new
	immolated.max_size = 15
	weapon_fired = LimitedArray.new
	weapon_fired.max_size = 15
	maelstromed = LimitedArray.new
	maelstromed.max_size = 15
	lightning_called = LimitedArray.new
	lightning_called.max_size = 15
	holy_bolted = LimitedArray.new
	holy_bolted.max_size = 15
	pestilenced = LimitedArray.new
	pestilenced.max_size = 15
	acid_covered = LimitedArray.new
	acid_covered.max_size = 15
	deity = nil
	divine_wrath_active = false
	divine_wrath_message = {
		'Charl'           => /^White sparks flicker around you, and you sense electrical energy gathering in the instant before a massive bolt of lightning spears toward/,
		'Cholen'          => /^A throwing knife formed of shimmering golden light hurtles from the hand of one of the spirit jesters toward/,
		'Eonak'           => /^Within the reddish haze swirling beside/,
		'Imaera'          => /^A brown stag materializes in midair, leaping out of nowhere to try to impale/,
		'Jastev'          => /^A beam of .*? light lances away from the rainbow around you to strike/,
		'Koar'            => /^An aura of divine golden light blazes into existence around/,
		'Lorminstra'      => /^As several faintly glowing snowflakes settle upon/,
		'Lumnis'          => /^Guided by the knowledge within you, you concentrate upon/,
		'Ronan'           => /^Seen only by your spirit gaze, one of the dream unicorns lowers its head and charges fiercely toward/,
		'Tonis'           => /^Accompanied by a particularly impressive gust of wind, a fleeting golden blur flashes past/,
		'Gosaena'         => /^An ethereal pair of feathered white wings materializes from midair and closes around/,
		'Zelia'           => /^You notice .*? nearby\\. How marvelous!/,
		'Eorgina'         => /^Shimmering black flames lash out toward/,
		'Fash\\'lo\\'nae' => /^A matte grey scalpel appears from midair, and it moves with evident purpose to take a deliberate, methodical slice at/,
		'Luukos'          => /^Long, spectral talons materialize from midair to tear viciously at the body of/,
		'Marlu'           => /^A tendril of black mist suddenly senses the proximity of/,
		'Mularos'         => /^The ethereal barbed whip that lies loosely coiled around you uncoils at terrifying speed\\. It snaps out toward/,
		'Sheru'           => /^Suddenly, .*? tries to bolt away, but instead smashes into a wall of spectral force hidden within the shadows!/,
		'V\\'tull'        => /^Divine will surges through you, and you command the scimitar to strike at/,
		'the Huntress'    => /^A silver-bladed scythe materializes from thin air, spinning end over end as it hurtles toward/,
		'Laethe'          => /^A shadowy black rose touches/,
		'Leya'            => /^A dagger of ivory light suddenly flashes away from the aura surrounding you to strike at/,
		'Niima'           => /^As the song from the pillar of water crescendos, it reaches a pitch that normally only trained bards can achieve, and the intense waves of elegant sound focus upon/,
		'Voaris'          => /^A glowing golden rose touches/,
		# fixme: missing Kai, Oleani, Phoen, Andelas, Ivas, Aeia, Amasalen, Arachne, Jaston, Kuon, Onar, Tilamaire, Voln
	}

	while line = get
		if line =~ /<stream id=\"thoughts\">/
			next
		elsif line =~ /^(?:<.*?>)?You nock an? .*?<a exist=\"(\\-?[0-9]+)\" noun=\"arrow\">/
			$loot_arrow_ids.push($1) unless $loot_arrow_ids.include?($1)
		elsif line =~ /^(?:<.*?>)?The scintillating light fades from an .*?<a exist=\"(\\-?[0-9]+)\" noun=\"arrows\">.*?<\\/a>\\./
			$loot_needs_eblade.push($1)
		elsif line =~ /^(?:<.*?>)?The scintillating .*?light surrounding the .*?<a exist=\"(\\-?[0-9]+)\" noun=\"arrow\">.*?<\\/a> fades away\\./
			$loot_needs_eblade.push($1)
		elsif line =~ /<comp(?:onent|Def) id='room objs'>.*?<a exist=\"(?:\#{$loot_arrow_ids.join('|')})\".*?<\\/comp(?:onent|Def)>/
			$loot_grab_list = ($loot_grab_list | GameObj.loot.to_a.find_all { |obj| $loot_arrow_ids.include?(obj.id) }.collect { |obj| obj.id }) - $loot_arrow_wait
		elsif line =~ /^(?:The|Glancing shot.  The|Bad angle.  The|Lacking the force and angle to lodge in .*?, the) <a exist=\"(\\-?[0-9]+)\" noun=\"arrow\">.*?<\\/a> (?:ricochets away from .*?, landing nearby\\.|zips past its target to the ground\\.|flips over, landing behind .*?\\.|fails to stick in .*?\\.|simply falls\\.|is deflected to one side, sailing to the ground\\.|disappears into the local environs|zips past its target to the ground\\.)/
			arrow_id = $1.dup
			if $loot_arrow_ids.include?(arrow_id) and not $loot_arrow_wait.include?(arrow_id)
				$loot_arrow_wait.push(arrow_id)
				Thread.new {
					sleep 16
					arrow_id = $loot_arrow_wait.shift
					unless $loot_grab_list.include?(arrow_id) or !GameObj.loot.any? { |obj| obj.id == arrow_id }
						$loot_grab_list.push(arrow_id)
					end
				}
				if (line =~ /disappears into the local environs/) and (room = Room.current)
					$loot_search_rooms.push(room.id)
				end
			end
		elsif (line =~ /You (?:swing|gesture|sing|weave another verse|continue to sing|channel|fire|wave|tap|rub|hurl|thrust|slash|throw|punch|attempt to punch|attempt to kick|attempt to throw|quickly dart behind .*? and try to hamstring|mentally attempt to locate your implanted essence|rush forward|exhale a virulent green mist)|You .*?attempt to (?:kick|punch|jab|grapple)|A wave of power flows out of you and toward|Abruptly, you sense the attention of your spirit slayer focus upon|Your (?:<.*?>)?raging sandstorm(?:<.*?>)? swirls around|^Your senses tingle, then become awash in a flood of power as the life leaves your hapless foe!|^The flames surrounding <pushBold\\/>an? <a exist=\"(?:\#{immolated.join('|')})\" noun=\".*?\">.*?<\\/a><popBold\\/> flare up violently\\.\\.\\.|^<pushBold\\/>An? <a exist=\"(?:\#{pestilenced.join('|')})\" noun=\".*?\">.*?<\\/a><popBold\\/> (?:.*? as virulent green mist passes through|convulses with a crippling affliction|skin necrotizes and falls away as an indiscernible mass|skin hardens into a black rot and begins to crumble causing)|^(?:The sickly green miasma around|Light and dark pockmarks appear on|A spiritual malady wracks|Pustules break out all over|Pus-filled sores erupt on|Painful, pus-filled bumps begin to appear on) <pushBold\\/>an? <a exist=\"(?:\#{pestilenced.join('|')})\" noun=\".*?\">.*?<\\/a><popBold\\/> (?:flares|causing)|A .*? leaps from a <a.*?>.*?<\\/a> <pushBold\\/>.*?<a exist=\"(?:\#{weapon_fired.join('|')})\".*?>.*?<\\/a><popBold\\/> is wielding\\.|(?:Brilliant flashes of lightning surround|Large hailstones pound relentlessly on|Violent winds tighten around|Large rocks swirl around) <pushBold\\/>.*?<a exist=\"(?:\#{maelstromed.join('|')})\" noun=\".*?\">.*?<\\/a><popBold\\/>\\.|Suddenly a lightning bolt explodes from the small thundercloud and strikes <pushBold\\/>.*?<a exist=\"(?:\#{lightning_called.join('|')})\" noun=\".*?\">.*?<\\/a><popBold\\/> with a brilliant flash!|^Holy water continues to burn away at .*?exist=\"(?:\#{holy_bolted.join('|')})\"|^Acid continues to eat away at .*?<a exist=\"(\#{acid_covered.join('|')})\"|A shimmering field of energy flashes around you, reflecting the magic/) or (divine_wrath_active and divine_wrath_message[deity] and line =~ divine_wrath_message[deity])
			next if line =~ /You gesture sharply/
			candidates = Array.new
			possible_holy_bolted = nil
			if line =~ /^You exhale a virulent green mist toward <pushBold\\/>.*?<a exist=\"(.*?)\" noun=\".*?\">.*?<\\/a><popBold\\/>, instantly infecting/
				pestilenced.push($1) unless pestilenced.include?($1)
			end
			while (line = get) and (line !~ /Roundtime|A little bit late for that don't you think|<prompt|<style id=\"roomName\"/)
				if (line =~ /^The glimmer of an? <a exist=\"(.*?)\" noun=\".*?\">.*?<\\/a> catches your eye/) or line =~ (/^<pushBold\\/>A <a exist=\".*?\" noun=\".*?\">.*?<\\/a><popBold\\/> releases a groan of mingled ecstasy and relief as <pushBold\\/><a exist=\".*?\" noun=\".*?\">.*?<\\/a><popBold\\/> fades away, leaving (?:an?|some) <a exist=\"(.*?)\" noun=\".*?\">.*?<\\/a> behind!$/)
					$loot_grab_list.push($1) unless $loot_grab_list.include?($1)
					next
				elsif line =~ /^As the last of .*? disappears, (.+) appears? in .*? place\\.$/
					$1.scan(/exist=\"(.*?)\"[^>]*>([^<]+)</).each { |i,n|
						$loot_grab_list.push(i) unless ($loot_settings['exclude'] and n =~ /\#{$loot_settings['exclude']}/)
					}
					next
				elsif (line =~ /<a exist=\"([^\"]+)\" noun=\"([^\"]+)\">([^<]+)<\\/a> falls to the ground\\./) or (line =~ /^(?:<.*?>)?It(?:<.*?>)? (?:also )?left .*?<a exist=\"([^\"]+)\" noun=\"([^\"]+)\">([^<]+)<\\/a>.*? behind\./)
					exist, noun, name = $1, $2, $3
					unless thing = GameObj.loot.find { |obj| obj.id == exist }
						next if GameObj.npcs.any? { |n| n.id == exist }
						thing = GameObj.new(exist, noun, name)
					end
					if thing.type.nil?
						Script.log \"\#{Time.now.strftime(\"%Y-%m-%d %I:%M%P\")}: missing type for: \#{thing.name}\"
					elsif (thing.type =~ /junk/) or ($loot_settings['exclude'] and thing.name =~ /\#{$loot_settings['exclude']}/)
						nil
					elsif thing.type =~ /\#{$loot_settings['loot-types']}/
						$loot_grab_list.push(thing.id) unless $loot_grab_list.include?(thing.id)
						unless thing.sellable or (thing.type =~ /herb/)
							Script.log \"\#{Time.now.strftime(\"%Y-%m-%d %I:%M%P\")}: missing sellable for: \#{thing.name}\"
						end
					end
					next
				elsif line =~ /^(?:The|Glancing shot.  The|Bad angle.  The|Lacking the force and angle to lodge in .*?, the) <a exist=\"(\\-?[0-9]+)\" noun=\"arrow\">.*?<\\/a> (?:ricochets away from .*?, landing nearby\\.|zips past its target to the ground\\.|flips over, landing behind .*?\\.|fails to stick in .*?\\.|simply falls\\.|is deflected to one side, sailing to the ground\\.|disappears into the local environs\\.|zips past its target to the ground\\.)/
					arrow_id = $1.dup
					if $loot_arrow_ids.include?(arrow_id) and not $loot_arrow_wait.include?(arrow_id)
						$loot_arrow_wait.push(arrow_id)
						Thread.new {
							sleep 16
							arrow_id = $loot_arrow_wait.shift
							$loot_grab_list.push(arrow_id) unless $loot_grab_list.include?(arrow_id) or !GameObj.loot.any? { |obj| obj.id == arrow_id }
						}
					end
					if (line =~ /disappears into the local environs/) and (room = Room.current)
						$loot_search_rooms.push(room.id)
					end
				elsif line =~ /Wisps of black smoke swirl around <pushBold\\/>.*?<a exist=\"(.*?)\" noun=\".*?\">.*?<\\/a><popBold\\/> and s?he bursts into flame!/
					immolated.push($1) unless immolated.include?($1)
				elsif line =~ /^You exhale a virulent green mist toward <pushBold\\/>.*?<a exist=\"(.*?)\" noun=\".*?\">.*?<\\/a><popBold\\/>, instantly infecting/
					pestilenced.push($1) unless pestilenced.include?($1)
				elsif line =~ /You successfully hit <pushBold\\/>.*?<a exist=\"(.*?)\".*?>.*?<\\/a><popBold\\/> <a.*?>.*?<\\/a> with the spell\\./
					weapon_fired.push($1) unless weapon_fired.include?($1)
				elsif line =~ /A stiff breeze begins to swirl around <pushBold\\/>.*?<a exist=\"(.*?)\" noun=\".*?\">.*?<\\/a><popBold\\/>\\./
					maelstromed.push($1) unless maelstromed.include?($1)
				elsif (Skills.slreligion >= 30) and (line =~ /You hurl a stream of holy water at <pushBold\\/>.*?<a exist=\"(.*?)\" noun=\".*?\">.*?<\\/a><popBold\\/>!/)
					possible_holy_bolted = $1
				elsif possible_holy_bolted and (line =~ /^\\s*AS\\: [\\+\\-][0-9]+ vs DS\\: [\\+\\-][0-9]+ with AvD\\: [\\+\\-][0-9]+ \\+ d100 roll\\: \\+[0-9]+ = ([\\+\\-])([0-9]+)/)
					if ($1 == '+') and ($2.to_i > 100)
						holy_bolted.push(possible_holy_bolted) unless holy_bolted.include?(possible_holy_bolted)
					end
				elsif line =~ /You notice a small cloud form above <pushBold\\/>.*?<a exist=\"(.*?)\" noun=\".*?\">.*?<\\/a><popBold\\/>\\./
					lightning_called.push($1)
				elsif line =~ /^As you pour your soul into an appeal to (.*?), /
					deity = $1
					divine_wrath_active = true
				elsif line =~ /^A final rumble of thunder rolls through the area, and, as its last echoes fade away, your skin ceases to tingle as your connection to Charl lessens\\.|^Your connection to Cholen lessens\\. The airy, brisk trill of a well-played fife and a quick cymbal crash heralds the departure of the spirit jesters\\.|^The ruddy haze near you dissipates, and the sound of the forging hammer dies away\\. As the forge-fire's heat leaves your skin, your connection to Eonak lessens\\.|^You sense the last of the spirit animals running away unseen, and the aroma of forest loam fades as your connection to Imaera lessens\\.|^The iridescent lights surrounding you pop like soap bubbles, one by one, until the last one bursts in a small flare of starry radiance and is gone\\. Your connection to Jastev lessens\\.|^Your connection to Koar lessens, and the divine light fades around you\\. The ground shudders one last time before falling still\\.|^As your connection to Lorminstra lessens, the snowflakes stop falling, and the few that still cling to you melt away\\. The icy cold gradually lifts from your body\\.|^As your connection to Lumnis lessens, the world of divine insight slips away from you, destroying the subtle understanding that you so briefly managed to grasp\\.|^You lose sight of the dream unicorns and the barren plain upon which they run as your connection to Ronan lessens\\. The waking world seems brighter again as the sense of dreamlike lassitude leaves you\\.|^You glimpse the golden blur one last time, but then you lose track of it entirely as your connection to Tonis lessens\\. The wind's force lessens as well, and then the air falls still\\.|^You realize that you had ceased to hear the sound of your own heartbeat only when you become aware of it again, and other sounds filter back into your awareness as well\\. Warmth returns to your body as your connection to Gosaena lessens\\.|^Suddenly, the important insights slip away, leaving you drained and exhausted as you plummet back to a more mundane state of mind\\. Your throat and sides are slightly sore, and your cheeks are wet with tears\\. Your connection to Zelia has lessened\\.|^Your connection to Eorgina lessens, and the black flames instantly vanish, leaving you stranded and bereft of the presence of the Arkati's power\\.|^Your connection to Fash'lo'nae lessens\\.  The quiet sound of a blade being honed persists a moment longer before fading away into silence\\.|^A spectral howl echoes through the air, resonant with pain and anguish\\. Your skin prickles again as your connection to Luukos lessens\\.|^As your connection to Mularos lessens, the cold, invisible collar locked about your throat fades into a compassionate caress, and a similar caress traces its way across the side of your cheek\\. Beneath that gentle touch, the wounds upon your face heal immediately\\. The ethereal barbed whip twitches one last time before dissolving back into air\\.|^Your connection to Sheru lessens, and the murky shadows brought by your appeal fade away, yet the feeling of being watched does not\\. On any night, in any dream or nightmare, those amber eyes will follow you endlessly\\.\\.\\. but such is the prize and the price of your devotion\\.|^As your connection to the Huntress lessens, the foreign anger that lent you strength passes from your body as well, and your heartbeat returns to its regular pace\\.|^You feel the kiss of benediction once more upon your brow, and then your connection to Laethe lessens\\. The shadowy black roses dissolve into tendrils of black, rose-scented smoke that dissipate rapidly\\.|^The ivory light around you fades and glimmers out, and the strength and control of your movements lessens along with your connection to Leya\\.|^The singing from the watery pillar begins to fade as your connection to Niima lessens\\. The pillar thins, then suddenly drops with a great splash! You are utterly drenched in water\\.|^You feel the kiss of benediction once more upon your brow, and then your connection to Voaris lessens\\. One of the glowing golden roses lights with scarlet flame, and the fire spreads rapidly down the vine until every rose is burning\\. The flames consume the roses swiftly and without smoke, until, in less than a second, the roses are gone entirely\\./
					# fixme: missing Kai, Oleani, Phoen, Andelas, Ivas, Marlu, V'tull, Aeia, Amasalen, Arachne, Jaston, Kuon, Onar, Tilamaire, Voln
					divine_wrath_active = false
				elsif line =~ /^\\s*Some of the acid sticks to .+? exist=\"(\\-?\\d+)\".+? and continues to bubble away!/
					acid_covered.push($1)
				end
				if line =~ /<a exist=['\"](.*?)['\"]/
					candidates.push($1) unless candidates.include?($1)
				end
			end
			for obj_id in candidates
				if (npc = GameObj.npcs.find { |npc| npc.id == obj_id }) and (npc.status == 'dead')
					unless $loot_dead_npcs.include?(obj_id)
						$loot_dead_npcs.push(obj_id) unless $loot_ignore_creatures and not $loot_ignore_creatures.empty? and (npc.name =~ /\#{$loot_ignore_creatures}/)
						$loot_stats['kills'] += 1
					end
				end
			end
		elsif line =~ /^You spy .*?<a exist=\"(.*?)\" noun=\".*?\">.*?<\\/a>, which looks like the heirloom that you are searching for!$/
			$loot_grab_list.push($1) unless $loot_grab_list.include?($1)
		elsif line =~ /^You cannot do that while berserking\.$|^Everything around you turns red as you work yourself into a berserker's rage!|^You rage across the battlefield, striking with unrelenting fury!/
			$loot_berserking = true
		elsif line =~ /^The redness fades from the world and you begin to breathe harder\.$/
			$loot_berserking = false
		end
	end
"
start_exec_script(exec_string, flags={ :quiet => true })

drag_to_sack = proc { |obj,sack|
	if failed_drag_lootsack[sack.id]
		unless (GameObj.right_hand.id == obj.id) or (GameObj.left_hand.id == obj.id)
			dothistimeout "get ##{obj.id}", 10, get_regex
		end
		result = dothistimeout "put ##{obj.id} in ##{sack.id}", 10, put_regex
	else
		result = dothistimeout "_drag ##{obj.id} ##{sack.id}", 10, put_regex
		if result =~ /^Do you want to put that in or on/
			failed_drag_lootsack[sack.id] = true
			result = dothistimeout "put ##{obj.id} in ##{sack.id}", 10, put_regex
		end
	end
	if result =~ /It's closed!/
		dothistimeout "open ##{sack.id}", 10, /^You open|^That is already open\./
		need_close_lootsack.push(sack.id)
		result = dothistimeout "put ##{obj.id} in ##{sack.id}", 10, put_regex
	end
	result
}

lootsack_put = proc { |obj|
	done_been_put = false
	rotate_lootsack = 0
	$loot_stats['loot_count'] += 1
	if (CharSettings['stow-herbs'] and herbsack and (obj.type =~ /herb/))
		result = drag_to_sack.call(obj, herbsack)
		unless result =~ /won't fit/
			done_been_put = true
		end
	end
	unless done_been_put
		for lootsack in lootsack_list
			result = drag_to_sack.call(obj, lootsack)
			if result =~ /won't fit/
				rotate_lootsack += 1
				watch_lootsack.call
			else
				if CharSettings['phase-boxes'] and (obj.type =~ /box/) and (obj.name !~ /mithril|enruned/) and Spell[704].known? and Spell[704].affordable?
					loop {
						result = cast 704, obj
						break unless (result =~ /^\[Spell Hindrance for/) and Spell[704].affordable?
					}
				end
				done_been_put = true
				break
			end
		end
		rotate_lootsack.times { lootsack_list.push(lootsack_list.shift) }
	end
	unless done_been_put
		fput "drop ##{obj.id}"
	end
}

loop {
	if ($loot_dead_npcs.empty? and $loot_grab_list.empty?) or $loot_berserking
		script.want_downstream = false
		clear
		wait_while { ($loot_dead_npcs.empty? and $loot_grab_list.empty?) or $loot_berserking }
	end
	begin
		$loot_working = true
		need_fill_hand = false
		need_fill_left_hand = false
		need_fill_right_hand = false
		save_stance = nil
		waitrt?
		script.want_downstream = true
		right_hand_save = GameObj.right_hand
		unless $loot_dead_npcs.empty?
			dead_npcs = Array.new
			while target = $loot_dead_npcs.shift
				if (dead_npc = GameObj.npcs.find { |npc| npc.id == target }) and (dead_npc.status == 'dead')
					dead_npcs.push(dead_npc)
				end
			end
			if CharSettings['skin'] and skinweapon and skinweaponsack and dead_npcs.any? { |npc| not Settings['unskinnable'].include?(npc.name) and (not both_skinnable.include?(npc.name) or not bluntskinweapon or not bluntskinweaponsack) and (not CharSettings['never-empty'] or (GameObj.right_hand.id == skinweapon.id and GameObj.left_hand.id.nil?) or (GameObj.left_hand.id == skinweapon.id and GameObj.right_hand.id.nil?) or (GameObj.left_hand.id.nil? and GameObj.right_hand.id.nil?) or not Settings['free-hand-skinnable'].include?(npc.name)) }
				unless (GameObj.right_hand.id == skinweapon.id) or (GameObj.left_hand.id == skinweapon.id)
					empty_hand
					need_fill_hand = true
					dothistimeout "get ##{skinweapon.id}", 10, get_regex
				end
				if CharSettings['604'] and (skinning = Spell[604]) and skinning.known? and skinning.affordable? and not skinning.active?
					skinning.cast
				end
				if CharSettings['kneel'] or (CharSettings['safe-kneel'] and not GameObj.npcs.any? { |npc| (npc.status !~ /dead/) and (npc.type !~ /passive/) })
					dothistimeout 'kneel', 5, /You kneel|You are already kneeling/
				end
				if CharSettings['stance'] and stance != 'offensive'
					save_stance = stance
					dothistimeout 'stance offensive', 5, /You are now in an offensive stance/
				end
				if CharSettings['empty'] and GameObj.right_hand.id and (GameObj.right_hand.id != skinweapon.id)
					need_fill_right_hand = true
					empty_right_hand
				end
				if CharSettings['empty'] and GameObj.left_hand.id and (GameObj.left_hand.id != skinweapon.id)
					need_fill_left_hand = true
					empty_left_hand
				end
				for target in dead_npcs
					unless (target.status =~ /gone/) or Settings['unskinnable'].include?(target.name) or (both_skinnable.include?(target.name) and bluntskinweapon and bluntskinweaponsack) or Settings['free-hand-skinnable'].include?(target.name)
						if GameObj.left_hand.id == skinweapon.id
							skin_result = dothistimeout "skin ##{target.id} left", 10, /^You (?:skinned|botched)|^You might want to wait until after it is dead|^You can only skin creatures|has already been skinned|^You cannot skin|^Could not find your target creature|unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through|^You need a free hand to do that!/
						else
							skin_result = dothistimeout "skin ##{target.id}", 10, /You (?:skinned|botched)|You might want to wait until after it is dead|You can only skin creatures|has already been skinned|You cannot skin|Could not find your target creature|unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through|^You need a free hand to do that!/
						end
						if skin_result =~ /You cannot skin/
							Settings['unskinnable'].push(target.name)
						elsif skin_result =~ /unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through/
							Settings['unskinnable'].push(target.name)
							Settings['blunt-skinnable'].push(target.name)
						elsif skin_result =~ /You need a free hand/
							Settings['free-hand-skinnable'].push(target.name)
						elsif skin_result =~ /yielding an? <a exist="(.*?)"/
							$loot_grab_list.push($1) unless $loot_grab_list.include?($1)
							$loot_stats['successful_skins'] += 1
						else
							$loot_stats['failed_skins'] += 1
						end
						if CharSettings['use-ambrominas'] and herbsack and (target.noun =~ injures_on_skin_regex) and ((Wounds.leftHand == 1) or (Wounds.rightHand == 1))
							close_herbsack = false
							if herbsack.contents.nil?
								r = dothistimeout "open ##{herbsack.id}", 5, /^You open|^That is already open/
								if r =~ /^You open/
									close_herbsack = true
								end
							end
							if (leaf = herbsack.contents.find { |obj| obj.name == 'some ambrominas leaf' })
								empty_hand
								dothistimeout "get ##{leaf.id}", 10, get_regex
								dothistimeout "eat ##{leaf.id}", 10, /^You take a bite/
								waitrt?
								if (GameObj.left_hand.id == leaf.id) or (GameObj.right_hand.id == leaf.id)
									dothistimeout "put ##{leaf.id} in ##{herbsack.id}", 10, put_regex
								end
								fill_hand
							end
							fput "close ##{herbsack.id}" if close_herbsack
						end
					end
				end
				if ((GameObj.right_hand.id == skinweapon.id and GameObj.left_hand.id.nil?) or (GameObj.left_hand.id == skinweapon.id and GameObj.right_hand.id.nil?) or (GameObj.left_hand.id.nil? and GameObj.right_hand.id.nil?) or not CharSettings['never-empty']) and dead_npcs.any? { |npc| (npc.status !~ /gone/) and not Settings['unskinnable'].include?(target.name) and Settings['free-hand-skinnable'].include?(target.name) }
					if GameObj.right_hand.id and (GameObj.right_hand.id != skinweapon.id)
						need_fill_right_hand = true
						empty_right_hand
					end
					if GameObj.left_hand.id and (GameObj.left_hand.id != skinweapon.id)
						need_fill_left_hand = true
						empty_left_hand
					end
					for target in dead_npcs
						unless (target.status =~ /gone/) or Settings['unskinnable'].include?(target.name) or not Settings['free-hand-skinnable'].include?(target.name)
							if GameObj.left_hand.id == skinweapon.id
								skin_result = dothistimeout "skin ##{target.id} left", 10, /^You (?:skinned|botched)|^You might want to wait until after it is dead|^You can only skin creatures|has already been skinned|^You cannot skin|^Could not find your target creature|unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through/
							else
								skin_result = dothistimeout "skin ##{target.id}", 10, /You (?:skinned|botched)|You might want to wait until after it is dead|You can only skin creatures|has already been skinned|You cannot skin|Could not find your target creature|unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through/
							end
							if skin_result =~ /You cannot skin/
								Settings['unskinnable'].push(target.name)
							elsif skin_result =~ /unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through/
								Settings['unskinnable'].push(target.name)
								Settings['blunt-skinnable'].push(target.name)
							elsif skin_result =~ /yielding an? <a exist="(.*?)"/
								$loot_grab_list.push($1) unless $loot_grab_list.include?($1)
								$loot_stats['successful_skins'] += 1
							else
								$loot_stats['failed_skins'] += 1
							end
						end
					end
				end
				if need_fill_hand
					dothistimeout "put ##{skinweapon.id} in ##{skinweaponsack.id}", 10, put_regex
				end
			end
			if CharSettings['skin'] and bluntskinweapon and bluntskinweaponsack and dead_npcs.any? { |npc| (Settings['blunt-skinnable'].include?(npc.name) or both_skinnable.include?(npc.name)) and (not CharSettings['never-empty'] or (GameObj.right_hand.id == bluntskinweapon.id and GameObj.left_hand.id.nil?) or (GameObj.left_hand.id == bluntskinweapon.id and GameObj.right_hand.id.nil?) or (GameObj.left_hand.id.nil? and GameObj.right_hand.id.nil?) or not Settings['free-hand-skinnable'].include?(npc.name)) }
				if CharSettings['604'] and (skinning = Spell[604]) and skinning.known? and skinning.affordable? and not skinning.active?
					skinning.cast
				end
				if CharSettings['empty'] and GameObj.right_hand.id and (GameObj.right_hand.id != bluntskinweapon.id)
					need_fill_right_hand = true
					empty_right_hand
				end
				if CharSettings['empty'] and GameObj.left_hand.id and (GameObj.left_hand.id != bluntskinweapon.id)
					need_fill_left_hand = true
					empty_left_hand
				end
				unless (GameObj.right_hand.id == bluntskinweapon.id) or (GameObj.left_hand.id == bluntskinweapon.id)
					empty_hand
					need_fill_hand = true
					dothistimeout("get ##{bluntskinweapon.id}", 10, get_regex)
				end
				if CharSettings['kneel'] or (CharSettings['safe-kneel'] and not GameObj.npcs.any? { |npc| npc.status !~ /dead/ })
					dothistimeout 'kneel', 5, /You kneel/
				end
				if CharSettings['stance'] and stance != 'offensive'
					save_stance = stance
					dothistimeout 'stance offensive', 5, /You are now in an offensive stance/
				end
				for target in dead_npcs
					if (target.status !~ /gone/) and (Settings['blunt-skinnable'].include?(target.name) or both_skinnable.include?(target.name)) and not Settings['free-hand-skinnable'].include?(target.name)
						if GameObj.left_hand.id == bluntskinweapon.id
							skin_result = dothistimeout "skin ##{target.id} left", 10, /^You (?:skinned|botched)|^You might want to wait until after it is dead|^You can only skin creatures|has already been skinned|^You cannot skin|^Could not find your target creature|unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through|You .*? withdraw (?:a|an|some) <a exist="\-?[0-9]+"|You .*? but find nothing\.|^You need a free hand to do that!/
						else
							skin_result = dothistimeout "skin ##{target.id}", 10, /You (?:skinned|botched)|You might want to wait until after it is dead|You can only skin creatures|has already been skinned|You cannot skin|Could not find your target creature|unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through|You .*? withdraw (?:a|an|some) <a exist="\-?[0-9]+"|You .*? but find nothing\.|^You need a free hand to do that!/
						end
						if skin_result =~ /You .*? withdraw (?:a|an|some) <a exist="(\-?[0-9]+)"/
							skin_id = $1
							$loot_stats['successful_skins'] += 1
							if GameObj.right_hand.id == skin_id
								lootsack_put.call(GameObj.right_hand)
							elsif GameObj.left_hand.id == skin_id
								lootsack_put.call(GameObj.left_hand)
							else
								$loot_grab_list.push(skin_id) unless $loot_grab_list.include?(skin_id)
							end
						elsif skin_result =~ /You cannot skin/
							Settings['unskinnable'].push(target.name)
						elsif skin_result =~ /unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through/
							Settings['unskinnable'].push(target.name)
						elsif skin_result =~ /You need a free hand to do that!/
							Settings['free-hand-skinnable'].push(target.name)
						elsif skin_result =~ /yielding an? <a exist="(.*?)"/
							$loot_grab_list.push($1) unless $loot_grab_list.include?($1)
							$loot_stats['successful_skins'] += 1
						else
							$loot_stats['failed_skins'] += 1
						end
					end
				end
				if ((GameObj.right_hand.id == bluntskinweapon.id and GameObj.left_hand.id.nil?) or (GameObj.left_hand.id == bluntskinweapon.id and GameObj.right_hand.id.nil?) or (GameObj.left_hand.id.nil? and GameObj.right_hand.id.nil?) or not CharSettings['never-empty']) and dead_npcs.any? { |npc| (npc.status !~ /gone/) and Settings['blunt-skinnable'].include?(target.name) and Settings['free-hand-skinnable'].include?(target.name) }
					if GameObj.right_hand.id and (GameObj.right_hand.id != bluntskinweapon.id)
						need_fill_right_hand = true
						empty_right_hand
					end
					if GameObj.left_hand.id and (GameObj.left_hand.id != bluntskinweapon.id)
						need_fill_left_hand = true
						empty_left_hand
					end
					for target in dead_npcs
						if (target.status !~ /gone/) and (Settings['blunt-skinnable'].include?(target.name) or both_skinnable.include?(target.name)) and Settings['free-hand-skinnable'].include?(target.name)
							if GameObj.left_hand.id == bluntskinweapon.id
								skin_result = dothistimeout "skin ##{target.id} left", 10, /^You (?:skinned|botched)|^You might want to wait until after it is dead|^You can only skin creatures|has already been skinned|^You cannot skin|^Could not find your target creature|unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through|You .*? withdraw (?:a|an|some) <a exist="\-?[0-9]+"|You .*? but find nothing\./
							else
								skin_result = dothistimeout "skin ##{target.id}", 10, /You (?:skinned|botched)|You might want to wait until after it is dead|You can only skin creatures|has already been skinned|You cannot skin|Could not find your target creature|unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through|You .*? withdraw (?:a|an|some) <a exist="\-?[0-9]+"|You .*? but find nothing\./
							end
							if skin_result =~ /You .*? withdraw (?:a|an|some) <a exist="(\-?[0-9]+)"/
								skin_id = $1
								$loot_stats['successful_skins'] += 1
								if GameObj.right_hand.id == skin_id
									lootsack_put.call(GameObj.right_hand)
								elsif GameObj.left_hand.id == skin_id
									lootsack_put.call(GameObj.left_hand)
								else
									$loot_grab_list.push(skin_id) unless $loot_grab_list.include?(skin_id)
								end
							elsif skin_result =~ /You cannot skin/
								Settings['unskinnable'].push(target.name)
							elsif skin_result =~ /unable to cut|^You are unable to (?:properly )?break through|^You cannot .*? break through/
								Settings['unskinnable'].push(target.name)
							elsif skin_result =~ /yielding an? <a exist="(.*?)"/
								$loot_grab_list.push($1) unless $loot_grab_list.include?($1)
								$loot_stats['successful_skins'] += 1
							else
								$loot_stats['failed_skins'] += 1
							end
						end
					end
				end
				if need_fill_hand
					dothistimeout "put ##{bluntskinweapon.id} in ##{bluntskinweaponsack.id}", 10, put_regex
				end
			end
			if need_fill_left_hand
				fill_left_hand
			end
			if need_fill_right_hand
				fill_right_hand
			end
			unless standing?
				fput 'stand'
				waitrt?
			end
			if save_stance
				fput "stance #{save_stance}"
			end
			for target in dead_npcs
				next if target.status =~ /gone/
				if target.noun =~ free_hand_search_regex
					empty_hand
					need_fill_hand = true
				end
				search_result = dothistimeout "search ##{target.id}", 10, /You (?:reach out to )?search|What were you referring to|Could not find a valid target to loot|You plunge your hand into|^You're not in any condition to be searching around!/
				if search_result =~ /You plunge your hand into .*? withdraw (?:your arm to find )?a .*? (\w+) (?:in your grasp|at the cost of freezing your hand)!/
					noun = $1
					if GameObj.right_hand.noun == noun
						obj = GameObj.right_hand
						lootsack_put.call(obj)
					elsif GameObj.left_hand.noun == noun
						obj = GameObj.left_hand
						lootsack_put.call(obj)
					else
						echo 'fixme'
					end
				elsif search_result =~ /You (?:reach out to )?search/
					while (line = get) and (line !~ /prompt/)
						if line =~ /exist="(.*?)".*which looks like the heirloom that you are searching for/
							$loot_grab_list.push($1) unless $loot_grab_list.include?($1)
						else
							for link in line.scan(/<a.*?>.*?<\/a>/)
								if link =~ /<a exist="(.*?)" noun="(.*?)">(.*?)<\/a>/
									exist, noun, name = $1, $2, $3
									next if name =~ /^(?:he|she|it|her|his|him|its|itself)$|'s$/i
									unless thing = GameObj.loot.find { |obj| obj.id == exist }
										thing = GameObj.new(exist, noun, name)
									end
									if thing.type.nil?
										Script.log "#{Time.now.strftime("%Y-%m-%d %I:%M%P")}: missing type for: #{thing.name}"
									elsif (thing.type =~ /junk/) or (CharSettings['exclude'] and thing.name =~ /#{CharSettings['exclude']}/)
										nil
									elsif thing.type =~ /#{CharSettings['loot-types']}/
										$loot_grab_list.push(thing.id) unless $loot_grab_list.include?(thing.id)
										unless thing.sellable or (thing.type =~ /herb/)
											Script.log "#{Time.now.strftime("%Y-%m-%d %I:%M%P")}: missing sellable for: #{thing.name}"
										end
									end
								end
							end
						end
					end
				end
				if CharSettings['use-ambrominas'] and herbsack and (target.noun =~ injures_on_search_regex) and ((Wounds.leftHand == 1) or (Wounds.rightHand == 1))
					close_herbsack = false
					if herbsack.contents.nil?
						r = dothistimeout "open ##{herbsack.id}", 5, /^You open|^That is already open/
						if r =~ /^You open/
							close_herbsack = true
						end
					end
					if (leaf = herbsack.contents.find { |obj| obj.name == 'some ambrominas leaf' })
						empty_hand
						dothistimeout "get ##{leaf.id}", 10, get_regex
						dothistimeout "eat ##{leaf.id}", 10, /^You take a bite/
						waitrt?
						if (GameObj.left_hand.id == leaf.id) or (GameObj.right_hand.id == leaf.id)
							dothistimeout "put ##{leaf.id} in ##{herbsack.id}", 10, put_regex
						end
						fill_hand
					end
					fput "close ##{herbsack.id}" if close_herbsack
				end
			end
		end
		if CharSettings['get-arrows'] and not $loot_search_rooms.empty? and not GameObj.npcs.any? { |npc| (npc.type !~ /passive npc/) and (npc.status !~ /dead/) } and (room = Room.current) and $loot_search_rooms.include?(room.id)
			$loot_search_rooms.count(room.id).times {
				dothistimeout 'search', 10, /^You don't find|^You spy|^You're not in any condition to be searching around!/
				waitrt?
			}
			$loot_search_rooms.delete(room.id)
		end
		if $loot_grab_list.empty?
			if need_fill_hand
				fill_hand
			end
		else
			need_close_disk = false
			unless need_fill_hand
				empty_hand
			end
			while obj_id = $loot_grab_list.shift
				unless obj = GameObj.loot.find { |o| o.id == obj_id }
					next if CharSettings['get-arrows'] and $loot_arrow_ids.include?(obj_id)
					dothistimeout "get ##{obj_id}", 10, get_regex
					if GameObj.right_hand.id == obj_id
						obj = GameObj.right_hand
					elsif GameObj.left_hand.id == obj_id
						obj = GameObj.left_hand
					else
						echo 'fixme'
						next
					end
				end
				if (obj.name == 'belt pouch')
					dothistimeout "look in ##{obj.id}", 5, /^In the|^That is closed|^I could not find/
					if (obj.contents.length == 1) and (obj.contents[0].name == 'some silver coins')
						fput "get coins from ##{obj.id}"
						sleep 0.2
						waitrt?
						next
					end
				end
				if (obj.type =~ /box/) and CharSettings['disk-boxes'] and ((disk = GameObj.loot.find { |o| o.name =~ /#{Char.name} disk$/ }) or reget.any? { |line| line =~ /^Your disk arrives, following you dutifully\.\r?$/ })
					25.times { break if GameObj.loot.any? { |o| o.name =~ /#{Char.name} disk$/ }; sleep 0.1 }
					if disk
						result = dothistimeout "_drag ##{obj.id} ##{disk.id}", 10, put_regex
						if result =~ /It's closed!/
							dothistimeout "open ##{disk.id}", 10, /^You open|^That is already open\./
							need_close_disk = true
							result = dothistimeout "_drag ##{obj.id} ##{disk.id}", 10, put_regex
						end
						if result =~ /You put/
							next
						end
					end
				end
				while CharSettings['eblade-arrows'] and (eblade = Spell[411]) and eblade.known? and eblade.affordable? and (arrow_id = $loot_needs_eblade.shift)
					if arrow = (GameObj.loot.to_a + arrowsack.contents.to_a).find { |obj| obj.id == arrow_id }
						waitcastrt?
						result = eblade.cast(arrow)
						if (result == false) or (result =~ /^\[Spell Hindrance/)
							arrow_id = $loot_needs_eblade.unshift(arrow_id)
						end
					end
				end
				if CharSettings['get-arrows'] and $loot_arrow_ids.include?(obj.id)
					next unless GameObj.loot.any? { |o| o.id == obj.id }
					next if $loot_arrow_wait.include?(obj.id)
					bundle_list = arrowsack.contents.find_all { |o| o.noun == 'arrows' }
					if (likely_bundle_id = likely_bundle_id_list[obj.full_name]) and (likely_bundle = bundle_list.find { |o| o.id == likely_bundle_id })
						# try the last working bundle for this arrow name first
						bundle_list.delete(likely_bundle)
						bundle_list.unshift(likely_bundle)
					end
					obj_full_name = obj.full_name # obj and name will change if gather is used
					for bundle in arrowsack.contents.find_all { |o| o.noun == 'arrows' }
						if GameObj.loot.find_all { |o| o.noun == 'arrow' }.length > 2
							result = dothistimeout "gather ##{obj.id}", 10, /^You gather|^You pick up|^You need a free hand to pick that up\.|^I could not find what you were referring to\.|^Get what\?|^The .*? is out of your reach\.|^You (?:deftly )?remove/
							if result =~ /^You gather|^You pick up/
								if GameObj.right_hand.noun =~ /^arrows?$/
									obj = GameObj.right_hand
								elsif GameObj.left_hand.noun =~ /^arrows?$/
									obj = GameObj.left_hand
								end
								result = dothistimeout "put my arrow in ##{bundle.id}", 10, /^You add|^You bundle|^I could not find what you were referring to\.|^You cannot bundle these together\./
							end
						else
							result = dothistimeout "_drag ##{obj.id} ##{bundle.id}", 10, /You add|You need a free hand to pick that up\.|^I could not find what you were referring to\.|^Get what\?|^The .*? is out of your reach\.|^You cannot bundle these together\./
						end
						if result =~ /^You add|^You bundle/
							likely_bundle_id_list[obj_full_name] = bundle.id
							break
						end
					end
					if (GameObj.right_hand.id == obj.id) or (GameObj.left_hand.id == obj.id) or GameObj.loot.any? { |o| o.id == obj.id }
						result = dothistimeout "_drag ##{obj.id} ##{arrowsack.id}", 10, put_regex
					end
				else
					lootsack_put.call(obj)
				end
			end
			fill_hand
			for lootsack_id in need_close_lootsack
				dothistimeout "close ##{lootsack_id}", 10, /^You close|^That is already closed;\./
			end
			need_close_lootsack.clear
			if need_close_disk
				dothistimeout "close ##{disk.id}", 10, /^You close|^That is already closed;\./
			end
		end
	ensure
		$loot_working = false
	end
}

=begin
	start second arrow bundle when charges run out
	keep track of charged/dead bundle
	option to bless dead arrows

	The scintillating red light surrounding the arrow fades away.

	only gather after kill
	only gather with no live npcs

	You are unable to properly break through the greater krynch's rocky hide with a straight razor.
	You are unable to break through the krag dweller's stone hide with a dagger!
=end
