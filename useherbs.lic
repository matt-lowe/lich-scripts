=begin

   Script to heal yourself with herbs.

   Will use herbs in your herbsack, or on a bench or something.
   Works with any combination of herbs from any town.
   Can buy herbs.
   Might heal your traveller.

   ;useherbs help

     author: Tillmen (tillmen@lichproject.org)
       game: Gemstone
       tags: healing
    version: 0.10
   requried: Lich >= 4.6.0

   changelog:
      0.10 (2017-09-30):
         add feature to fill your herbsack with herbs (;useherbs stock herbs)
      0.9 (2017-03-04):
         remove 506 from the script, since it doesn't affect eating herbs anymore
      0.8 (2017-01-14):
         withdraw silvers first when using the "stock potions" command

=end
=begin

      0.7 (2015-04-26):
         fix for working with hidden containers, like the basket in Ta'Vaalor
      0.6 (2015-03-28):
         remember to look on/under/behind a container instead of "in" if a second look is required
         fix bug with finding a herbsack given on the command line
      0.5 (2015-02-23):
         better method of finding container from herbsack setting
      0.4 (2014-12-12):
         make "stock potions" track potion use instead of measuring every time
      0.3 (2014-11-14):
         set herbsack with ;useherbs set herbsack <container>

=end

# fixme: garland of sovyn cloves
# fixme: skip more better
# fixme: buy herbs/right hand full
# fixme: use bank note

$known_herbs = [
   { :name=>"some acantha leaf",                :type=>"blood",              :short_name => "acantha leaf",   :store_doses=>10 },
   { :name=>"some spicy acantha leaf",          :type=>"blood",              :short_name => "spicy acantha leaf",   :store_doses=>10 },
   { :name=>"tincture of acantha",              :type=>"blood",              },
   { :name=>"tincture of yabathilium",          :type=>"blood",              },
   { :name=>"yabathilium fruit",                :type=>"blood",              },
   { :name=>"iceberry tart",                    :type=>"blood",              :store_doses=>10 },
   { :name=>"some acantha leaf tea",            :type=>"blood",              :short_name => "acantha leaf tea" },
   { :name=>"grey mushroom potion",             :type=>"blood",              },
   { :name=>"flagon of Olak's Ol'style ale",    :type=>"blood",              :short_name => "Olak's Ol'style ale" },
   { :name=>"barrel of Olak's Ol'style ale",    :type=>"blood",              :short_name => "Olak's Ol'style ale" },
   { :name=>"flagon of Bloody Krolvin ale",     :type=>"blood",              :short_name => "Bloody Krolvin ale" },
   { :name=>"barrel of Bloody Krolvin ale",     :type=>"blood",              :short_name => "Bloody Krolvin ale" },
   { :name=>"some aloeas stem",                 :type=>"major head wound",   :short_name => "aloeas stem",   :store_doses=>2 },
   { :name=>"some withered aloeas stem",        :type=>"major head wound",   :short_name => "withered aloeas stem",   :store_doses=>2 },
   { :name=>"tincture of aloeas",               :type=>"major head wound",   },
   { :name=>"tiny ram's bladder tart",          :type=>"major head wound",   :short_name => "ram's bladder tart", :store_doses=>2 },
   { :name=>"feverfew potion",                  :type=>"major head wound",   },
   { :name=>"sticky lichen tea",                :type=>"major head wound",   },
   { :name=>"flagon of Dark Swampwater ale",    :type=>"major head wound",   :short_name => "Dark Swampwater ale" },
   { :name=>"barrel of Dark Swampwater ale",    :type=>"major head wound",   :short_name => "Dark Swampwater ale" },
   { :name=>"rose-marrow potion",               :type=>"minor head wound",   :store_doses=>4 },
   { :name=>"crystalline rose-marrow elixir",   :type=>"minor head wound",   },
   { :name=>"tincture of rose-marrow",          :type=>"minor head wound",   },
   { :name=>"elk horn potion",                  :type=>"minor head wound",   :store_doses=>4 },
   { :name=>"some feverfew tea",                :type=>"minor head wound",   :short_name => "feverfew tea" },
   { :name=>"rusty red ale",                    :type=>"minor head wound",   },
   { :name=>"flagon of Semak's Smooth ale",     :type=>"minor head wound",   :short_name => "Semak's Smooth ale" },
   { :name=>"barrel of Semak's Smooth ale",     :type=>"minor head wound",   :short_name => "Semak's Smooth ale" },
   { :name=>"brostheras potion",                :type=>"major head scar",    :store_doses=>2 },
   { :name=>"crystalline brostheras elixir",    :type=>"major head scar",    },
   { :name=>"tincture of brostheras",           :type=>"major head scar",    },
   { :name=>"tiny cup of polar bear fat soup",  :type=>"major head scar",    :store_doses=>2, :short_name => 'polar bear fat soup' },
   { :name=>"pennyroyal potion",                :type=>"major head scar",    },
   { :name=>"stone soot brew",                  :type=>"major head scar",    },
   { :name=>"flagon of Reaper's Red ale",       :type=>"major head scar",    :short_name => "Reaper's Red ale" },
   { :name=>"barrel of Reaper's Red ale",       :type=>"major head scar",    :short_name => "Reaper's Red ale" },
   { :name=>"some haphip root",                 :type=>"minor head scar",    :short_name => "haphip root",   :store_doses=>4 },
   { :name=>"some dirty haphip root",           :type=>"minor head scar",    :short_name => "dirty haphip root",   :store_doses=>4 },
   { :name=>"tincture of haphip",               :type=>"minor head scar",    },
   { :name=>"slice of sparrowhawk pie",         :type=>"minor head scar",    :store_doses=>5, :short_name => 'sparrowhawk pie' },
   { :name=>"pennyroyal tea",                   :type=>"minor head scar",    },
   { :name=>"dull crimson ale",                 :type=>"minor head scar",    },
   { :name=>"flagon of Agrak's Amber ale",      :type=>"minor head scar",    :short_name => "Agrak's Amber ale" },
   { :name=>"barrel of Agrak's Amber ale",      :type=>"minor head scar",    :short_name => "Agrak's Amber ale" },
   { :name=>"some pothinir grass",              :type=>"major organ wound",  :short_name => "pothinir grass",   :store_doses=>2 },
   { :name=>"some bright green pothinir grass", :type=>"major organ wound",  :short_name => "pothinir grass",   :store_doses=>2 },
   { :name=>"tincture of pothinir",             :type=>"major organ wound",  },
   { :name=>"tiny musk ox tart",                :type=>"major organ wound",    :short_name => 'musk ox tart', :store_doses=>2 },
   { :name=>"ginkgo nut potion",                :type=>"major organ wound",  },
   { :name=>"roasted ratweed tea",              :type=>"major organ wound",  },
   { :name=>"flagon of Aged Schooner ale",      :type=>"major organ wound",  :short_name => "Aged Schooner ale" },
   { :name=>"barrel of Aged Schooner ale",      :type=>"major organ wound",  :short_name => "Aged Schooner ale" },
   { :name=>"some basal moss",                  :type=>"minor organ wound",  :short_name => "basal moss",   :store_doses=>4 },
   { :name=>"tincture of moss",                 :type=>"minor organ wound",  },
   { :name=>"sticky ball of basal moss",        :type=>"minor organ wound",  :store_doses=>4 },
   { :name=>"tincture of basal",                :type=>"minor organ wound",  },
   { :name=>"small egg and tundra grass tart",  :type=>"minor organ wound",  :store_doses=>5, :short_name => 'tundra grass tart' },
   { :name=>"some ginkgo nut tea",              :type=>"minor organ wound",  :short_name => "ginkgo nut tea" },
   { :name=>"chunky black ale",                 :type=>"minor organ wound",  },
   { :name=>"flagon of Mama Dwarf's ale",       :type=>"minor organ wound",  :short_name => "Mama Dwarf's ale" },
   { :name=>"barrel of Mama Dwarf's ale",       :type=>"minor organ wound",  :short_name => "Mama Dwarf's ale" },
   { :name=>"wingstem potion",                  :type=>"major organ scar",   :store_doses=>2 },
   { :name=>"crystalline wingstem elixir",      :type=>"major organ scar",   },
   { :name=>"tincture of wingstem",             :type=>"major organ scar",   },
   { :name=>"earthworm potion",                 :type=>"major organ scar",   :store_doses=>2 },
   { :name=>"wyrmwood root potion",             :type=>"major organ scar",   },
   { :name=>"dirty crevice brew",               :type=>"major organ scar",   },
   { :name=>"flagon of Wort's Winter ale",      :type=>"major organ scar",   :short_name => "Wort's Winter ale" },
   { :name=>"barrel of Wort's Winter ale",      :type=>"major organ scar",   :short_name => "Wort's Winter ale" },
   { :name=>"talneo potion",                    :type=>"minor organ scar",   :store_doses=>4 },
   { :name=>"crystalline talneo elixir",        :type=>"minor organ scar",   },
   { :name=>"tincture of talneo",               :type=>"minor organ scar",   },
   { :name=>"rock lizard potion",               :type=>"minor organ scar",   :store_doses=>4 },
   { :name=>"wyrmwood root tea",                :type=>"minor organ scar",   },
   { :name=>"brown weedroot ale",               :type=>"minor organ scar",   },
   { :name=>"flagon of Gert's Homemade ale",    :type=>"minor organ scar",   :short_name => "Gert's Homemade ale" },
   { :name=>"barrel of Gert's Homemade ale",    :type=>"minor organ scar",   :short_name => "Gert's Homemade ale" },
   { :name=>"bur-clover potion",                :type=>"missing eye",        :store_doses=>1 },
   { :name=>"crystalline bur-clover elixir",    :type=>"missing eye",        },
   { :name=>"tincture of bur-clover",           :type=>"missing eye",        },
   { :name=>"starfish potion",                  :type=>"missing eye",        :store_doses=>1 },
   { :name=>"daggit root potion",               :type=>"missing eye",        },
   { :name=>"dirty rat fur potion",             :type=>"missing eye",        },
   { :name=>"flagon of Volcano Vision ale",     :type=>"missing eye",        :short_name => "Volcano Vision ale" },
   { :name=>"barrel of Volcano Vision ale",     :type=>"missing eye",        :short_name => "Volcano Vision ale" },
   { :name=>"some ephlox moss",                 :type=>"major limb wound",   :short_name => "ephlox moss",   :store_doses=>4 },
   { :name=>"gooey ball of ephlox moss",        :type=>"major limb wound",   },
   { :name=>"tincture of ephlox",               :type=>"major limb wound",   },
   { :name=>"some frog's bone porridge",        :type=>"major limb wound",   :store_doses=>4, :short_name => "frog's bone porridge" },
   { :name=>"sweetfern potion",                 :type=>"major limb wound",   },
   { :name=>"crushed cavegrass tea",            :type=>"major limb wound",   },
   { :name=>"flagon of Golden Goose ale",       :type=>"major limb wound",   :short_name => "Golden Goose ale" },
   { :name=>"barrel of Golden Goose ale",       :type=>"major limb wound",   :short_name => "Golden Goose ale" },
   { :name=>"some ambrominas leaf",             :type=>"minor limb wound",   :short_name => "ambrominas leaf",   :store_doses=>4 },
   { :name=>"some sugary ambrominas leaf",      :type=>"minor limb wound",   :short_name => "sugary ambrominas leaf" },
   { :name=>"tincture of ambrominas",           :type=>"minor limb wound",   },
   { :name=>"Dabbings Family special tart",     :type=>"minor limb wound",   :store_doses=>4, :short_name => 'Family special tart' },
   { :name=>"some sweetfern tea",               :type=>"minor limb wound",   :short_name => "sweetfern tea" },
   { :name=>"bubbling brown ale",               :type=>"minor limb wound",   },
   { :name=>"flagon of Lost Dogwater ale",      :type=>"minor limb wound",   :short_name => "Lost Dogwater ale" },
   { :name=>"barrel of Lost Dogwater ale",      :type=>"minor limb wound",   :short_name => "Lost Dogwater ale" },
   { :name=>"some calamia fruit",               :type=>"major limb scar",    :short_name => "calamia fruit",   :store_doses=>2 },
   { :name=>"some ripe calamia fruit",          :type=>"major limb scar",    :short_name => "ripe calamia fruit" },
   { :name=>"tincture of calamia",              :type=>"major limb scar",    },
   { :name=>"slice of pickled walrus blubber",  :type=>"major limb scar",    :store_doses=>2, :short_name => 'pickled walrus blubber' },
   { :name=>"manroot potion",                   :type=>"major limb scar",    },
   { :name=>"stalactite brew",                  :type=>"major limb scar",    },
   { :name=>"flagon of Mad Mutt Frothy ale",    :type=>"major limb scar",    :short_name => "Mad Mutt Frothy ale" },
   { :name=>"barrel of Mad Mutt Frothy ale",    :type=>"major limb scar",    :short_name => "Mad Mutt Frothy ale" },
   { :name=>"some cactacae spine",              :type=>"minor limb scar",    :short_name => "cactacae spine",   :store_doses=>4 },
   { :name=>"some prickly cactacae spine",      :type=>"minor limb scar",    :short_name => "prickly cactacae spine" },
   { :name=>"tincture of cactacae",             :type=>"minor limb scar",    },
   { :name=>"gelatinous elk fat tart",          :type=>"minor limb scar",    :short_name => 'elk fat tart', :store_doses=>10 },
   { :name=>"manroot tea",                      :type=>"minor limb scar",    },
   { :name=>"spotted toadstool ale",            :type=>"minor limb scar",    },
   { :name=>"flagon of Bearded Ladies' ale",    :type=>"minor limb scar",    :short_name => "Bearded Ladies' ale" },
   { :name=>"barrel of Bearded Ladies' ale",    :type=>"minor limb scar",    :short_name => "Bearded Ladies' ale" },
   # fixme
   { :name=>"some sovyn clove",                 :type=>"severed limb",       :short_name => "sovyn clove",   :store_doses=>1 },
   { :name=>"sovyn clove",                      :type=>"severed limb",       },
   { :name=>"tincture of sovyn",                :type=>"severed limb",       },
   { :name=>"candied ptarmigan feather",        :type=>"severed limb",       :short_name => 'ptarmigan feather', :store_doses=>1 },
   { :name=>"angelica root potion",             :type=>"severed limb",       },
   { :name=>"grainy black potion",              :type=>"severed limb",       },
   { :name=>"flagon of Captn' Pegleg's ale",    :type=>"severed limb",       :short_name => "Captn' Pegleg's ale" },
   { :name=>"barrel of Captn' Pegleg's ale",    :type=>"severed limb",       :short_name => "Captn' Pegleg's ale" },
   { :name=>"bolmara potion",                   :type=>"major nerve wound",  :store_doses=>4 },
   { :name=>"crystalline bolmara elixir",       :type=>"major nerve wound",  },
   { :name=>"tincture of bolmara",              :type=>"major nerve wound",  },
   { :name=>"snowflake elixir",                 :type=>"major nerve wound",  :store_doses=>4 },
   { :name=>"red lichen potion",                :type=>"major nerve wound",  },
   { :name=>"glowing mold tea",                 :type=>"major nerve wound",  },
   { :name=>"flagon of Kenar's Dropjaw ale",    :type=>"major nerve wound",  :short_name => "Kenar's Dropjaw ale" },
   { :name=>"barrel of Kenar's Dropjaw ale",    :type=>"major nerve wound",  :short_name => "Kenar's Dropjaw ale" },
   { :name=>"some wolifrew lichen",             :type=>"minor nerve wound",  :short_name => "wolifrew lichen",   :store_doses=>4 },
   { :name=>"some dry wolifrew lichen",         :type=>"minor nerve wound",  :short_name => "dry wolifrew lichen", },
   { :name=>"tincture of wolifrew",             :type=>"minor nerve wound",  },
   { :name=>"Leaftoe's lichen tart",            :type=>"minor nerve wound",  :store_doses=>4, :short_name => 'lichen tart' },
   { :name=>"some red lichen tea",              :type=>"minor nerve wound",  :short_name => "red lichen tea" },
   { :name=>"thick foggy ale",                  :type=>"minor nerve wound",  },
   { :name=>"flagon of Orc's Head ale",         :type=>"minor nerve wound",  :short_name => "Orc's Head ale" },
   { :name=>"barrel of Orc's Head ale",         :type=>"minor nerve wound",  :short_name => "Orc's Head ale" },
   { :name=>"some woth flower",                 :type=>"major nerve scar",   :short_name => "woth flower",   :store_doses=>2 },
   { :name=>"some fragrant woth flower",        :type=>"major nerve scar",   :short_name => "fragrant woth flower" },
   { :name=>"tincture of woth",                 :type=>"major nerve scar",   },
   { :name=>"tiny flower-shaped tart",          :type=>"major nerve scar",   :store_doses=>2, :short_name => 'flower-shaped tart' },
   { :name=>"valerian root potion",             :type=>"major nerve scar",   },
   { :name=>"stalagmite brew",                  :type=>"major nerve scar",   },
   { :name=>"flagon of Dacra's Dream ale",      :type=>"major nerve scar",   :short_name => "Dacra's Dream ale" },
   { :name=>"barrel of Dacra's Dream ale",      :type=>"major nerve scar",   :short_name => "Dacra's Dream ale" },
   { :name=>"some torban leaf",                 :type=>"minor nerve scar",   :short_name => "torban leaf",   :store_doses=>3 },
   { :name=>"some fresh torban leaf",           :type=>"minor nerve scar",   :short_name => "fresh torban leaf" },
   { :name=>"tincture of torban",               :type=>"minor nerve scar",   },
   { :name=>"slice of Ma Leaftoe's Special",    :type=>"minor nerve scar",   :store_doses=>5, :short_name => "Ma Leaftoe's Special" },
   { :name=>"valerian root tea",                :type=>"minor nerve scar",   },
   { :name=>"dark frothing ale",                :type=>"minor nerve scar",   },
   { :name=>"flagon of Miner's Muddy ale",      :type=>"minor nerve scar",   :short_name => "Miner's Muddy ale" },
   { :name=>"barrel of Miner's Muddy ale",      :type=>"minor nerve scar",   :short_name => "Miner's Muddy ale" },
   { :name=>"dimly glowing sky-blue potion",    :type=>"disease",            },
   { :name=>"dimly glowing sea-green potion",   :type=>"poison",             },
]

#silence_me

drinkable         = /potion|tea|elixir|brew|tincture|ale|soup/
skippable         = Array.new
close_herbsack    = false
preposition       = 'in'
return_to_stow    = false
herb_container    = nil
right_hand_save   = nil
left_hand_save    = nil
buy_missing       = CharSettings['buy_missing']
use_mending       = CharSettings['use-mending']
start_room        = Room.current
herb_shop_menu    = nil
silvers           = nil
withdraw_amount   = 8000
should_deposit    = false
used_herbs        = Array.new
open_regex        = /^You open|^That is already open\.$|^There doesn't seem to be any way to do that\.$|^What were you referring to\?|^I could not find what you were referring to\./
close_regex       = /^You close|^That is already closed\.$/
put_regex         = /^You (?:attempt to shield .*? from view as you |discreetly |carefully |absent-mindedly )?(?:put|place|slip|tuck|add|hang|drop|untie your|find an incomplete bundle|wipe off .*? and sheathe)|^A sigh of grateful pleasure can be heard as you feed .*? to your|^As you place|^I could not find what you were referring to\.$|^Your bundle would be too large|^The .+ is too large to be bundled\.|^As you place your|^The .*? is already a bundle|^Your .*? won't fit in .*?\.$|^You can't .+ It's closed!$/
put_fail_regex    = /^Your .*? won't fit in .*?\.$|^You can't .+ It's closed!$||^I could not find what you were referring to\.$/
get_regex         = /^You (?:shield the opening of .*? from view as you |discreetly |carefully |deftly )?(?:remove|draw|grab|reach|slip|tuck|retrieve|already have|unsheathe|detach)|^Get what\?$|^Why don't you leave some for others\?$|^You need a free hand|^You already have that/
get_from          = nil

min_stock_doses = {
   'major head scar'   => 13,
   'minor head wound'  => 11,
   'major nerve wound' => 11,
   'minor organ scar'  => 11,
   'major organ scar'  => 13,
   'missing eye'       => 7,
}

check_silvers = proc {
   action = proc { |server_string|
      if server_string =~ /^\s*Name\:|^\s*Gender\:|^\s*Normal \(Bonus\)|^\s*Strength \(STR\)\:|^\s*Constitution \(CON\)\:|^\s*Dexterity \(DEX\)\:|^\s*Agility \(AGI\)\:|^\s*Discipline \(DIS\)\:|^\s*Aura \(AUR\)\:|^\s*Logic \(LOG\)\:|^\s*Intuition \(INT\)\:|^\s*Wisdom \(WIS\)\:|^\s*Influence \(INF\)\:/
         nil
      elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+[0-9]+/
         DownstreamHook.remove("#{script.name}_check_silvers")
         nil
      else
         server_string
      end
   }
   DownstreamHook.add("#{script.name}_check_silvers", action)
   silence_me unless undo_silence = silence_me
   clear
   put 'info'
   silence_me if undo_silence
   while line = get
      if line =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9]+)/
         silvers = $1.to_i
         break
      end
   end
   silvers
}

withdraw = proc {
   Script.run('go2', 'bank --disable-confirm')
   fput 'unhide' if invisible?
   if XMLData.room_title == '[Pinefar, Depository]'
      if GameObj.npcs.any? { |npc| npc.noun == 'banker' }
         fput "ask banker for #{[withdraw_amount.to_i, 20].max} silvers"
            # The banker nods and says, "Alright, here ye go.  Ye understand I be takin' a little more than that from ye account in the 'Mule.  I don't works for free!"
            # The banker looks at you suspiciously and says, "Hmm, I don't think ye be havin' enough in ye account to cover that and my fee.  Ye tryin' to pull one over on me?"
      else
         if icemule_bank = Room.list.find { |room| room.location == 'Icemule Trace' and room.tags.include?('bank') }
            Script.run('go2', icemule_bank.id.to_s)
            result = dothistimeout "withdraw #{withdraw_amount} silvers", 1, /debt collector/
            if result =~ /debt collector/
               fput "withdraw #{withdraw_amount} silvers"
            end
         else
            echo 'waiting for banker...'
            wait_until { GameObj.npcs.any? { |npc| npc.noun == 'banker' } }
            fput "ask banker for #{[withdraw_amount.to_i, 20].max} silvers"
         end
      end
   else
      result = dothistimeout "withdraw #{withdraw_amount} silvers", 1, /debt collector/
      if result =~ /debt collector/
         fput "withdraw #{withdraw_amount} silvers"
      end
   end
   silvers += withdraw_amount
   should_deposit = true
}

deposit = proc {
   if should_deposit
      Script.run('go2', 'bank --disable-confirm')
      if XMLData.room_title == '[Pinefar, Depository]'
         if GameObj.npcs.any? { |npc| npc.noun == 'banker' }
            fput "give banker #{check_silvers.call} silvers"
         end
      else
         fput "deposit #{check_silvers.call}"
      end
   end
}

too_wounded_to_cast = proc {
   ([Wounds.head, Scars.head, Wounds.nsys, Scars.nsys].max > 1) or ([Wounds.leftArm, Wounds.leftHand, Wounds.rightArm, Wounds.rightHand, Scars.leftArm, Scars.leftHand, Scars.rightArm, Scars.rightHand].max > 2) or ( ([Wounds.leftArm, Wounds.leftHand, Scars.leftArm, Scars.leftHand].max > 0) and ([Wounds.rightArm, Wounds.rightHand, Scars.leftArm, Scars.leftHand].max > 0) )
}

go_to_herbalist = proc {
   if working_herbalist = Room.current.find_nearest(Room.list.find_all { |room| room.tags.include?('herbalist') and not room.title.any? { |t| t =~ /Valina's Herbs and Tinctures|Marroux and Haert, Chirurgeons/ } })
      Script.run('go2', working_herbalist.to_s)
   else
      Script.run('go2', 'herbalist --disable-confirm')
   end
}

next_herb_type = proc {
   herb_type = nil
   #unless herb_type or skippable.include?('disease')
   #  if checkdisease
   #     herb_type = 'disease'
   #  end
   #end
   #unless herb_type or skippable.include?('poison')
   #  if checkpoison
   #     herb_type = 'poison'
   #  end
   #end
   unless herb_type
      herb_type = 'blood' if (percenthealth < 50) and not skippable.include?('blood')
   end
   unless herb_type
      for area in [ 'head', 'neck', 'torso', 'limbs', 'nerves' ] - skippable
         if Wounds.send(area) > 1
            area = 'head' if area == 'neck'
            area = 'organ' if area == 'torso'
            area = 'limb' if area == 'limbs'
            area = 'nerve' if area == 'nerves'
            herb_type = "major #{area} wound"
            break
         end
      end
   end
   unless herb_type
      for area in [ 'head', 'neck', 'torso', 'limbs', 'nerves' ] - skippable
         if Wounds.send(area) == 1
            area = 'head' if area == 'neck'
            area = 'organ' if area == 'torso'
            area = 'limb' if area == 'limbs'
            area = 'nerve' if area == 'nerves'
            herb_type = "minor #{area} wound"
            break
         end
      end
   end
   unless herb_type
      herb_type = 'severed limb' if (Scars.limbs == 3) and not skippable.include?('limbs')
   end
   unless herb_type
      herb_type = 'missing eye' if (Scars.reye == 3 or Scars.leye == 3) and not skippable.include?('torso')
   end
   unless herb_type
      for area in [ 'head', 'neck', 'torso', 'limbs', 'nerves' ] - skippable
         if Scars.send(area) > 1
            area = 'head' if area == 'neck'
            area = 'organ' if area == 'torso'
            area = 'limb' if area == 'limbs'
            area = 'nerve' if area == 'nerves'
            herb_type = "major #{area} scar"
            break
         end
      end
   end
      unless herb_type
         for area in [ 'head', 'neck', 'torso', 'limbs', 'nerves' ] - skippable
            if Scars.send(area) == 1
               area = 'head' if area == 'neck'
               area = 'organ' if area == 'torso'
               area = 'limb' if area == 'limbs'
               area = 'nerve' if area == 'nerves'
               herb_type = "minor #{area} scar"
               break
            end
         end
      end
   unless herb_type
      herb_type = 'blood' if (checkhealth + 7) < maxhealth and not skippable.include?('blood')
   end
   herb_type
}

stow_herb = proc {
   if return_to_stow and (Room.current.id != start_room.id)
      Script.run('go2', start_room.id.to_s)
   end
   if used_herbs.include?(GameObj.right_hand.id)
      dothistimeout "put ##{GameObj.right_hand.id} #{preposition} ##{herb_container.id}", 10, put_regex
      fput('stow right') if checkright
   end
   if used_herbs.include?(GameObj.left_hand.id)
      dothistimeout "put ##{GameObj.left_hand.id} #{preposition} ##{herb_container.id}", 10, put_regex
      fput('stow left') if checkleft
   end
}

read_menu = proc {
   status_tags
   clear
   fput 'unhide' if hidden? or invisible?
   fput 'order'
   menu = Hash.new
   while (line = get) and (line !~ /ORDER|BUY/)
      for item in line.scan(/<d.*?cmd=["']order ([0-9]+).*?>(.*?)<\/d>/)
         menu[item[1].sub(/^a /, '')] = item[0]
      end
   end
   status_tags
   clear
   menu
}

buy_herb = proc { |herb_type|
   unless silvers
      silvers = check_silvers.call
   end
   unless herb_shop_menu
      herb_shop_menu = read_menu.call
   end
   herb_name = herb_shop_menu.keys.find { |name| $known_herbs.any? { |h| (h[:type] == herb_type) and (name =~ /#{h[:name]}/ or name =~ /#{h[:name].sub(/sticky |gooey | green| fragrant| shiny| dirty/, '')}/) } }
   unless order_number = herb_shop_menu[herb_name]
      echo "error: failed to find a herb for #{herb_type} in the menu"
      exit
   end
   dothistimeout "order #{order_number}", 3, /BUY/
   buy_result = dothistimeout 'buy', 3, /Sold for [0-9]+ silver|^But you do not have enough silver!/
   if buy_result =~ /Sold for ([0-9]+) silver/
      silvers -= $1.to_i
   elsif buy_result =~ /^But you do not have enough silver!/
      withdraw.call
      go_to_herbalist.call
      redo
   else
      silvers = check_silvers.call
   end
   if checkright
      GameObj.right_hand
   else
      nil
   end
}

if script.vars[0] =~ /help/i
   respond
   respond 'To use the herbs in your herbsack (see below for setting your herbsack):'
   respond
   respond '   ;useherbs'
   respond
   respond 'To use the herbs on a bench or something:'
   respond
   respond '   ;useherbs on bench'
   respond
   respond '   ;useherbs behind altar'
   respond
   respond 'To use the herbs on a bench without picking up the edible herbs:'
   respond
   respond '   ;useherbs on bench --no-get'
   respond
   respond 'To look up what herbs heal what:'
   respond
   respond '   ;useherbs list'
   respond
   respond '   Append any combination of these to the previous example to narrow down the list: minor, major, severed, missing, head, organ, limb, nerve, eye, blood, wound, scar'
   respond
   respond "To heal your Adventurer's Guild escort (not well tested):"
   respond
   respond '   ;useherbs escort'
   respond
   respond 'Options (add these to the end of the command; these override default options):'
   respond
   respond '   --buy=<on/off>         Go to the herbalist to buy herbs if needed'
   respond '   --mending=<on/off>     Use sigil of mending before using herbs'
   respond
   respond "Change default options (so you don't have to specify the option every time):"
   respond
   respond '   ;useherbs set buy <on/off>           same as above'
   respond '   ;useherbs set mending <on/off>       same as above'
   respond "   ;useherbs set herbsack <container>   sets which container you use if one isn't"
   respond '                                        specified on the command line'
   respond 
   exit
elsif script.vars[1] =~ /^list$/i
      known_herbs = $known_herbs.dup
   if (script.vars[0] =~ /major|severed|missing/i) and (script.vars[0] !~ /minor/i)
      known_herbs.delete_if { |herb| herb[:type] !~ /major|severed|missing/i }
   elsif (script.vars[0] =~ /minor/i) and (script.vars[0] !~ /major|severed|missing/i)
      known_herbs.delete_if { |herb| herb[:type] !~ /minor/ }
   end
   if (script.vars[0] =~ /wound/i) and (script.vars[0] !~ /scar|missing|severed/i)
      known_herbs.delete_if { |herb| herb[:type] !~ /wound/ }
   elsif (script.vars[0] =~ /scar|missing|severed/i) and (script.vars[0] !~ /wound/i)
      known_herbs.delete_if { |herb| herb[:type] !~ /scar|missing|severed/ }
   end
   if script.vars[0] =~ /head|neck|organ|limb|leg|arm|hand|nerve|eye|blood|health|poison|posion|disease/
      known_herbs.delete_if { |herb| herb[:type] =~ /head/ } unless script.vars[0] =~ /head|neck/
      known_herbs.delete_if { |herb| herb[:type] =~ /organ|eye/ } unless script.vars[0] =~ /organ|eye/
      known_herbs.delete_if { |herb| herb[:type] =~ /limb/ } unless script.vars[0] =~ /limb|leg|arm|hand/
      known_herbs.delete_if { |herb| herb[:type] =~ /nerve/ } unless script.vars[0] =~ /nerve/
      known_herbs.delete_if { |herb| herb[:type] =~ /blood/ } unless script.vars[0] =~ /blood|health/
      known_herbs.delete_if { |herb| herb[:type] =~ /poison/ } unless script.vars[0] =~ /poison|posion/
      known_herbs.delete_if { |herb| herb[:type] =~ /disease/ } unless script.vars[0] =~ /disease/
   end
   list = Hash.new
   for herb in $known_herbs
      list[herb[:type]] ||= Array.new
      list[herb[:type]].push(herb[:name])
   end
   output = "\n"
   for type,herbs in list
      output.concat "#{monsterbold_start}#{type}:#{monsterbold_end} #{herbs.join(', ')}\n"
   end
   output.concat "\n"
   if defined?(_respond)
      _respond output
   else
      puts output
   end
   exit
elsif script.vars[1] == 'set'
   if script.vars[2] == 'buy'
      if script.vars[3] =~ /^(?:on|true|yes)$/
         CharSettings['buy_missing'] = true
         echo 'setting saved'
      elsif script.vars[3] =~ /^(?:off|false|no)$/
         CharSettings['buy_missing'] = false
         echo 'setting saved'
      else
         echo "error: bad setting value: #{script.vars[3]}"
      end
   elsif script.vars[2] == 'mending'
      if script.vars[3] =~ /^(?:on|true|yes)$/
         CharSettings['use-mending'] = true
         echo 'setting saved'
      elsif script.vars[3] =~ /^(?:off|false|no)$/
         CharSettings['use-mending'] = false
         echo 'setting saved'
      else
         echo "error: bad setting value: #{script.vars[3]}"
      end
   elsif script.vars[2] == 'herbsack'
      if script.vars[3]
         name = script.vars[3..-1].join(' ')
         obj_list = GameObj.inv.find_all { |obj| obj.noun == name }
         if obj_list.empty?
            obj_list = GameObj.inv.find_all { |obj| obj.name == name }
         end
         if obj_list.empty?
            obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{Regexp.escape(name)}$/i }
         end
         if obj_list.empty?
            obj_list = GameObj.inv.find_all { |obj| obj.name =~ /\b#{name.split(' ').collect { |n| Regexp.escape(n) }.join(".*\\b")}/i }
         end
         if obj_list.empty?
            echo "error: failed to find a container in your inventory by the name of \"#{name}\""
         elsif obj_list.length > 1
            echo "error: multiple containers in your inventory match the name \"#{name}\""
         else
            UserVars.herbsack = name
            echo 'setting saved'
         end
      else
         echo 'error: no container name given'
      end
   else
      echo "error: unknown setting: #{script.vars[2]}"
   end
   exit
elsif script.vars[1] =~ /^buy=(on|off|true|false|yes|no)$/ # depreciated
   fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
   CharSettings['buy_missing'] = fix_option[$1]
   echo 'setting saved'
   exit
elsif script.vars[1] =~ /^mending=(on|off|true|false|yes|no)$/ # depreciated
   fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
   CharSettings['use-mending'] = fix_option[$1]
   echo 'setting saved'
   exit
elsif script.vars[1].downcase == 'fill'
   # 5-7 doses: There is a good bit left in the rose-marrow potion.
   # 3-4 doses: There is a small amount in the rose-marrow potion.
   # 1-2 doses: There is just a little left in the rose-marrow potion.

   if UserVars.herbsack.nil? or UserVars.herbsack.empty?
      echo 'herbsack is not set (;useherbs set herbsack <container name>)'
      exit
   end
   unless herb_container = (GameObj.inv.find { |obj| obj.noun == UserVars.herbsack } || GameObj.inv.find { |obj| obj.name == UserVars.herbsack } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.herbsack)}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{UserVars.herbsack.split(' ').collect { |n| Regexp.escape(n) }.join(".*\\b")}/i })
      echo "error: unable to find container \"#{UserVars.herbsack}\" in your inventory."
      exit
   end
   close_herbsack = false
   if herb_container.contents.nil?
      open_result = dothistimeout "open ##{herb_container.id}", 10, open_regex
      if open_result =~ /^You open/
         close_herbsack = true
      else
         dothistimeout "look in ##{herb_container.id}", 10, /In the .*? you see/
         if herb_container.contents.nil?
            echo 'fixme 2'
            exit
         end
      end
   end
   unless silvers
      silvers = check_silvers.call
   end
   unless silvers > 4000
      withdraw.call
   end
   Script.run('go2', '325')
   herb_shop_menu = read_menu.call
   for herb_type in [ 'blood', 'major head wound', 'minor head wound', 'major head scar', 'minor head scar', 'major organ wound', 'minor organ wound', 'major organ scar', 'minor organ scar', 'missing eye', 'major limb wound', 'minor limb wound', 'major limb scar', 'minor limb scar', 'severed limb', 'major nerve wound', 'minor nerve wound', 'major nerve scar', 'minor nerve scar' ]
      unless herb_container.contents.any? { |obj| $known_herbs.any? { |herb| (herb[:name] == obj.name) and herb[:type] == herb_type } }
         #echo "no herb for #{herb_type}"
         herb_name = herb_shop_menu.keys.find { |name| $known_herbs.any? { |h| (h[:type] == herb_type) and (name =~ /#{h[:name]}/ or name =~ /#{h[:name].sub(/sticky |gooey | green| fragrant| shiny| dirty/, '')}/) } }
         unless order_number = herb_shop_menu[herb_name]
            echo "error: failed to find a herb for #{herb_type} in the menu"
            exit
         end
         dothistimeout "order #{order_number}", 3, /BUY/
         buy_result = dothistimeout 'buy', 3, /Sold for [0-9]+ silver|^But you do not have enough silver!/
         if buy_result =~ /Sold for ([0-9]+) silver/
            silvers -= $1.to_i
         elsif buy_result =~ /^But you do not have enough silver!/
            withdraw.call
            go_to_herbalist.call
            redo
         else
            silvers = check_silvers.call
         end
         if checkright
            herb = GameObj.right_hand
            dothistimeout "put ##{herb.id} #{preposition} ##{herb_container.id}", 10, put_regex
            if herb_info = $known_herbs.find { |h| h[:name] =~ /#{herb.name}$/ }
               $count_herbs[herb.id] = herb_info[:store_doses]
            end
         end
      end
   end
   fput "close ##{herb_container.id}" if close_herbsack
   Script.run('go2', start_room.id.to_s)
   exit
elsif script.vars[1].downcase == 'escort'
   if script.vars[2]
      unless escort = GameObj.npcs.find { |npc| (npc.id == script.vars[2]) or (npc.noun == script.vars[2]) }
         echo "Failed to find an npc with id or noun #{script.vars[2]}."
         exit
      end
   else
      unless escort = GameObj.npcs.find { |npc| npc.type =~ /escort/ }
         echo "Failed to find an escort."
         exit
      end
   end
   close_herbsack = false
   unless herb_container = (GameObj.inv.find { |obj| obj.noun == UserVars.herbsack } || GameObj.inv.find { |obj| obj.name == UserVars.herbsack } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.herbsack)}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{UserVars.herbsack.split(' ').collect { |n| Regexp.escape(n) }.join(".*\\b")}/i })
      echo "error: unable to find container \"#{UserVars.herbsack}\" in your inventory."
      exit
   end
   if herb_container.contents.nil?
      open_result = dothistimeout "open ##{herb_container.id}", 10, open_regex
      if open_result =~ /^You open/
         close_herbsack = true
      else
         dothistimeout "look in ##{herb_container.id}", 10, /In the .*? you see/
         if herb_container.contents.nil?
            echo "error: failed to find herb container contents (#{herb_container.name}, #{herb_container.id})"
            exit
         end
      end
   end
   look_result = dothistimeout "look ##{escort.id}", 10, /^(?:She|He) appears to be in good shape\.|^(?:She|He) has|^I could not find what you were referring to\./
   if look_result.nil?
      echo "error: timeout while trying to look at escort (#{escort.name}, #{escort.id})"
   elsif look_result =~ /^I could not find what you were referring to\./
      echo "error: can't see escort"
   elsif look_result =~ /^(?:She|He) appears to be in good shape\./
      echo 'nothing to do'
   elsif look_result =~ /^(?:She|He) has/
      escort_injuries = Array.new
      if look_result =~ /severe head trauma and bleeding from the ears/
         escort_injuries.push('major head wound')
         escort_injuries.push('major head wound')
         escort_injuries.push('minor head wound')
      end
      if look_result =~ /minor lacerations about the head and a possible mild concussion/
         escort_injuries.push('major head wound')
         escort_injuries.push('minor head wound')
      end
      if look_result =~ /snapped bones and serious bleeding from the neck/
         escort_injuries.push('major head wound')
         escort_injuries.push('major head wound')
         escort_injuries.push('minor head wound')
      end
      if look_result =~ /moderate bleeding from (?:his|her) neck/
         escort_injuries.push('major head wound')
         escort_injuries.push('minor head wound')
      end
      if look_result =~ /deep gashes and serious bleeding from (?:his|her) chest/
         escort_injuries.push('major organ wound')
         escort_injuries.push('major organ wound')
         escort_injuries.push('minor organ wound')
      end
      if look_result =~ /deep lacerations across (?:his|her) chest/
         escort_injuries.push('major organ wound')
         escort_injuries.push('minor organ wound')
      end
      if look_result =~ /deep gashes and serious bleeding from (?:his|her) abdomen/
         escort_injuries.push('major organ wound')
         escort_injuries.push('major organ wound')
         escort_injuries.push('minor organ wound')
      end
      if look_result =~ /deep lacerations across (?:his|her) abdomen/
         escort_injuries.push('major organ wound')
         escort_injuries.push('minor organ wound')
      end
      if look_result =~ /deep gashes and serious bleeding from (?:his|her) back/
         escort_injuries.push('major organ wound')
         escort_injuries.push('major organ wound')
         escort_injuries.push('minor organ wound')
      end
      if look_result =~ /deep lacerations across (?:his|her) back/
         escort_injuries.push('major organ wound')
         escort_injuries.push('minor organ wound')
      end
      if look_result =~ /a blinded right eye/
#        escort_injuries.push('missing eye')
         escort_injuries.push('major organ wound')
         escort_injuries.push('major organ wound')
         escort_injuries.push('minor organ wound')
      end
      if look_result =~ /a blinded left eye/
#        escort_injuries.push('missing eye')
         escort_injuries.push('major organ wound')
         escort_injuries.push('major organ wound')
         escort_injuries.push('minor organ wound')
      end
      if look_result =~ /a swollen right eye/
         escort_injuries.push('major organ wound')
         escort_injuries.push('minor organ wound')
      end
      if look_result =~ /a swollen left eye/
         escort_injuries.push('major organ wound')
         escort_injuries.push('minor organ wound')
      end
      if look_result =~ /a completely severed right leg/
         escort_injuries.push('major limb wound')
         escort_injuries.push('major limb wound')
         escort_injuries.push('minor limb wound')
      end
      if look_result =~ /a completely severed left leg/
         escort_injuries.push('major limb wound')
         escort_injuries.push('major limb wound')
         escort_injuries.push('minor limb wound')
      end
      if look_result =~ /a completely severed right arm/
         escort_injuries.push('major limb wound')
         escort_injuries.push('major limb wound')
         escort_injuries.push('minor limb wound')
      end
      if look_result =~ /a completely severed left arm/
         escort_injuries.push('major limb wound')
         escort_injuries.push('major limb wound')
         escort_injuries.push('minor limb wound')
      end
      if look_result =~ /a completely severed right hand/
         escort_injuries.push('major limb wound')
         escort_injuries.push('major limb wound')
         escort_injuries.push('minor limb wound')
      end
      if look_result =~ /a completely severed left hand/
         escort_injuries.push('major limb wound')
         escort_injuries.push('major limb wound')
         escort_injuries.push('minor limb wound')
      end
      if look_result =~ /a fractured and bleeding right leg/
         escort_injuries.push('major limb wound')
         escort_injuries.push('minor limb wound')
      end
      if look_result =~ /a fractured and bleeding left leg/
         escort_injuries.push('major limb wound')
         escort_injuries.push('minor limb wound')
      end
      if look_result =~ /a fractured and bleeding right arm/
         escort_injuries.push('major limb wound')
         escort_injuries.push('minor limb wound')
      end
      if look_result =~ /a fractured and bleeding left arm/
         escort_injuries.push('major limb wound')
         escort_injuries.push('minor limb wound')
      end
      if look_result =~ /a fractured and bleeding right hand/
         escort_injuries.push('major limb wound')
         escort_injuries.push('minor limb wound')
      end
      if look_result =~ /a fractured and bleeding left hand/
         escort_injuries.push('major limb wound')
         escort_injuries.push('minor limb wound')
      end
      if look_result =~ /a case of uncontrollable convulsions/
         escort_injuries.push('major nerve wound')
         escort_injuries.push('minor nerve wound')
      end
      if look_result =~ /a case of sporadic convulsions/
         escort_injuries.push('major nerve wound')
         escort_injuries.push('minor nerve wound')
      end
      if look_result =~ /minor bruises about the head/
         escort_injuries.push('minor head wound')
      end
      if look_result =~ /minor bruises on (?:his|her) neck/
         escort_injuries.push('minor head wound')
      end
      if look_result =~ /minor cuts and bruises on (?:his|her) chest/
         escort_injuries.push('minor organ wound')
      end
      if look_result =~ /minor cuts and bruises on (?:his|her) abdomen/
         escort_injuries.push('minor organ wound')
      end
      if look_result =~ /minor cuts and bruises on (?:his|her) back/
         escort_injuries.push('minor organ wound')
      end
      if look_result =~ /a bruised right eye/
         escort_injuries.push('minor organ wound')
      end
      if look_result =~ /a bruised left eye/
         escort_injuries.push('minor organ wound')
      end
      if look_result =~ /some minor cuts and bruises on (?:his|her) right leg/
         escort_injuries.push('minor limb wound')
      end
      if look_result =~ /some minor cuts and bruises on (?:his|her) left leg/
         escort_injuries.push('minor limb wound')
      end
      if look_result =~ /some minor cuts and bruises on (?:his|her) right arm/
         escort_injuries.push('minor limb wound')
      end
      if look_result =~ /some minor cuts and bruises on (?:his|her) left arm/
         escort_injuries.push('minor limb wound')
      end
      if look_result =~ /some minor cuts and bruises on (?:his|her) right hand/
         escort_injuries.push('minor limb wound')
      end
      if look_result =~ /some minor cuts and bruises on (?:his|her) left hand/
         escort_injuries.push('minor limb wound')
      end
      if look_result =~ /a strange case of muscle twitching/
         escort_injuries.push('minor nerve wound')
      end
      echo escort_injuries.inspect
      empty_right_hand
      for herb_type in escort_injuries
         herb = nil
         if $known_herbs.any? { |h| h[:type] == herb_type and (h[:name] == GameObj.right_hand.name or (h[:short_name] and h[:short_name] == GameObj.right_hand.name)) }
            herb = GameObj.right_hand
         elsif $known_herbs.any? { |h| h[:type] == herb_type and (h[:name] == GameObj.left_hand.name or (h[:short_name] and h[:short_name] == GameObj.left_hand.name)) }
            herb = GameObj.left_hand
         else
            stow_herb.call
            if herb = herb_container.contents.find { |i| $known_herbs.find { |h| (h[:name] == i.name) and h[:type] == herb_type } }
               used_herbs.push(herb.id) unless used_herbs.include?(herb.id)
               get_result = dothistimeout "get ##{herb.id}", 5, get_regex
               if get_result.nil? or (get_result =~ /^Get what\?/)
                  echo "error: timeout while trying to get herb (#{herb.name}, #{herb.id})"
                  dothistimeout "close ##{herb_container.id}", 5, close_regex if close_herbsack
                  exit
               elsif get_result =~ /^You need a free hand for that\./
                  echo 'fixme 28382'
                  dothistimeout "close ##{herb_container.id}", 5, close_regex if close_herbsack
                  exit
               end
            end
         end
         if herb
            dothistimeout "give ##{escort.id}", 10, /accepts your .* hands it back to you|ignores your offer/
         end
      end
      stow_herb.call
      fill_right_hand
   end
   if close_herbsack
      dothistimeout "close ##{herb_container.id}", 5, close_regex
   end
   exit
elsif script.vars[1].downcase == 'stock'
   close_herbsack = false
   if UserVars.herbsack.nil? or UserVars.herbsack.empty?
      echo 'herbsack is not set (;useherbs set herbsack <container name>)'
      exit
   end
   unless herb_container = (GameObj.inv.find { |obj| obj.noun == UserVars.herbsack } || GameObj.inv.find { |obj| obj.name == UserVars.herbsack } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.herbsack)}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{UserVars.herbsack.split(' ').collect { |n| Regexp.escape(n) }.join(".*\\b")}/i })
      echo "error: unable to find container \"#{UserVars.herbsack}\" in your inventory."
      exit
   end
   if herb_container.contents.nil?
      open_result = dothistimeout "open ##{herb_container.id}", 10, open_regex
      if open_result =~ /^You open/
         close_herbsack = true
      else
         dothistimeout "look in ##{herb_container.id}", 10, /In the .*? you see/
         if herb_container.contents.nil?
            echo "error: timeout while trying to look in herb container (#{herb_container.name}, #{herb_container.id})"
            exit
         end
      end
   end

   if $useherbs_measure.nil?
      exec_string = "
         hide_me
         status_tags
         $useherbs_measure = Hash.new
         using = nil
         last_left_hand_id = nil
         begin
            while line = get
               if line =~ /<left exist=\"([0-9]+)\"/
                  last_left_hand_id = $1
               end
               if line =~ /<prompt/
                  using = nil
               elsif using
                  if line =~ /^You have only about ([0-9]+) quaffs left\\./
                     $useherbs_measure[using] = $1.to_i
                  elsif line =~ /^You have (?:about )?([0-9]+) (?:doses|bites) left\\./
                     $useherbs_measure[using] = $1.to_i
                  elsif line =~ /^You (?:only )?have one bite left\\./
                     $useherbs_measure[using] = 1
                  elsif line =~ /^You have only about one quaff left\\.|You only have one (?:dose|quaff) left\\./
                     $useherbs_measure[using] = 1
                  elsif line =~ /^That was the last (?:drop|of it)\\./
                     $useherbs_measure[using] = 0
                  end
               elsif line =~ /^You take a (?:drink from|bite of) your .*? exist=\"([0-9]+)\"/
                  using = $1
               elsif line =~ /^You carefully pour a little bit from your .*? exist=\"([0-9]+)\" .*? into .*? exist=\"([0-9]+)\"/
                  using = $1
                  if $useherbs_measure[$2]
                     $useherbs_measure[$2] += 1
                  end
               elsif line =~ /^The .*? exist=\"([0-9]+)\" .*? has several doses left\\./
                  if $useherbs_measure[$1].nil? or ($useherbs_measure[$1] < 5) or ($useherbs_measure[$1] > 10)
                     $useherbs_measure[$1] = 7
                  end
               elsif line =~ /^The .*? exist=\"([0-9]+)\" .*? has a few doses left\\./
                  if $useherbs_measure[$1].nil? or ($useherbs_measure[$1] < 3) or ($useherbs_measure[$1] > 4)
                     $useherbs_measure[$1] = 4
                  end
               elsif line =~ /^The .*? exist=\"([0-9]+)\" .*? has 2 doses left\\./
                  $useherbs_measure[$1] = 2
               elsif line =~ /^The .*? exist=\"([0-9]+)\" .*? has 1 dose left\\./
                  $useherbs_measure[$1] = 1
               elsif line =~ /^You can't tell exactly, but .*? exist=\"(.*?)\" .*? seems to have plenty of bites left\\.$/
                  if $useherbs_measure[$1].nil? or ($useherbs_measure[$1] < 11) or ($useherbs_measure[$1] > 50)
                     $useherbs_measure[$1] = 50
                  end
               elsif line =~ /^The .*? exist=\"(.*?)\" .*? looks like it has several bites left\\.$/
                  if $useherbs_measure[$1].nil? or ($useherbs_measure[$1] < 5) or ($useherbs_measure[$1] > 10)
                     $useherbs_measure[$1] = 10
                  end
               elsif line =~ /^The .*? exist=\"(.*?)\" .*? looks like it has a few bites left\\.$/
                  if $useherbs_measure[$1].nil? or ($useherbs_measure[$1] < 3) or ($useherbs_measure[$1] > 4)
                     $useherbs_measure[$1] = 4
                  end
               elsif line =~ /^The .*? exist=\"(.*?)\" .*? has 2 bites left\\.$/
                  $useherbs_measure[$1] = 2
               elsif line =~ /^The .*? exist=\"(.*?)\" .*? has one bite left\\.$/
                  $useherbs_measure[$1] = 1
               elsif line =~ /^He hands you <a.*?exist=\"([0-9]+)\".*?>(#{$known_herbs.collect { |h| h[:name] }.join('|')})<\\/a> and says, \"Here's your purchase./o
                  doses = $known_herbs.find { |h| h[:name] == $2 }[:store_doses]
                  if doses.nil?
                     echo \"warning: no store_doses entry for \#{$2}\"
                     doses = 4
                  end
                  $useherbs_measure[$1] = doses
               elsif line =~ /^Carefully, you combine all your <a exist=\"([0-9]+)\".*? into one bundle\\./
                  if $useherbs_measure[$1] and $useherbs_measure[last_left_hand_id]
                     $useherbs_measure[$1] += $useherbs_measure[last_left_hand_id]
                     $useherbs_measure.delete(last_left_hand_id)
                  elsif ($useherbs_measure[$1] and $useherbs_measure[$1] > 10) or ($useherbs_measure[last_left_hand_id] and $useherbs_measure[last_left_hand_id] > 10)
                     # bundle has 11 - 50 bytes
                     # overestimate so that we don't buy more than we can bundle
                     # exact count will be found if the herb is used
                     $useherbs_measure[$1] = 50
                     $useherbs_measure.delete(last_left_hand_id)
                  else
                     # bundle has 2-50 bytes
                     # clear count so the bundle gets measured
                     $useherbs_measure.delete($1)
                     $useherbs_measure.delete(last_left_hand_id)
                  end
               elsif line =~ /^You carefully remove one dose from your <a exist=\"([0-9]+)\"/
                  if $useherbs_measure[$1]
                     $useherbs_measure[$1] -= 1
                  end
                  $useherbs_measure[last_left_hand_id] = 1
               end
               line
            end
         ensure
            $useherbs_measure = nil
         end
      "
      start_exec_script(exec_string, flags={ :quiet => true })
   end
#exit
   if script.vars[2].nil? or (script.vars[2].downcase == 'potions')
      herb_type_list = [ 'major head scar', 'minor head wound', 'major nerve wound', 'minor organ scar', 'major organ scar', 'missing eye' ]
      done_empty_hand = false
      herb_container.contents.each { |obj|
         if $known_herbs.any? { |h| herb_type_list.include?(h[:type]) and (h[:name] == obj.name) } and $useherbs_measure[obj.id].nil?
            if obj.noun == 'potion'
               result = dothistimeout "look in ##{obj.id}", 5, /^There is (?:a good|a small|just a little)/
               if result =~ /good/ # 5-7 doses
                  $useherbs_measure[obj.id] = 7
               elsif result =~ /small/ # 3-4 doses
                  $useherbs_measure[obj.id] = 4
               elsif result =~ /little/ # 1-2 doses
                  $useherbs_measure[obj.id] = 2
               else
                  echo 'fixme 293823'
               end
            else
               unless done_empty_hand
                  empty_hand
                  done_empty_hand = true
               end
               dothistimeout "get ##{obj.id}", 10, get_regex
               dothistimeout "measure ##{obj.id}", 10, /^The .*? left/
               dothistimeout "put ##{obj.id} in ##{herb_container.id}", 10, put_regex
            end
         end
      }
      done_gone_to_herbalist = false
      for herb_type in herb_type_list
         last_total_doses = -1
         loop {
            herb_list = herb_container.contents.find_all { |obj| $known_herbs.find { |h| (h[:name] == obj.name) and h[:type] == herb_type } }
            total_doses = 0; herb_list.each { |h| total_doses += $useherbs_measure[h.id].to_i }
            echo "#{herb_type}: #{total_doses}"
            break unless total_doses < min_stock_doses[herb_type]
            break unless total_doses > last_total_doses
            last_total_doses = total_doses
            echo "need more #{herb_type}"
            unless done_gone_to_herbalist
               if check_silvers.call < 1500
                  withdraw.call
               end
               go_to_herbalist.call
               done_gone_to_herbalist = true
            end
            if new_herb = buy_herb.call(herb_type)
               if (herb_info = $known_herbs.find { |h| h[:short_name] == new_herb.name }) and (store_doses = herb_info[:store_doses])
                  $useherbs_measure[new_herb.id] = store_doses
               end
               for old_herb in herb_list
                  10.times {
                     if (GameObj.right_hand.id == new_herb.id) or (GameObj.left_hand.id == new_herb.id)
                        result = dothistimeout "pour ##{new_herb.id} in ##{old_herb.id}", 5, /^You carefully pour|^You can't pour|^I can't find that|^I could not find what you were referring to/
                        if result =~ /^You can't pour any more in there without spilling it\./
                           $useherbs_measure[old_herb.id] = 7 # fixme: barrels hold 10
                           break
                        elsif result =~ /^You can't pour|^I can't find that|^I could not find what you were referring to/
                           break
                        end
                     else
                        break
                     end
                  }
               end
               if (GameObj.right_hand.id == new_herb.id) or (GameObj.left_hand.id == new_herb.id)
                  dothistimeout "_drag ##{new_herb.id} ##{herb_container.id}", 10, put_regex
               end
            end
         }
      end
      fill_hand if done_empty_hand
   end
   if script.vars[2].nil? or (script.vars[2].downcase == 'herbs')
      done_empty_hands = false
      nearest_herbalist_id = Room.current.find_nearest_by_tag('herbalist')
      nearest_herbalist_id or raise "can't find a path to a herbalist from here"
      unless Room[nearest_herbalist_id].location =~ /Wehnimer's|Solhaven/
         echo "stocking herbs is only supported in Wehnimer's and Solhaven (they sell herbs that can be bundled)"
         exit # fixme: go back to start room?
      end
      shopping_list = Array.new
      for herb in [ "some acantha leaf", "some aloeas stem", "some haphip root", "some pothinir grass", "some basal moss", "some ephlox moss", "some ambrominas leaf", "some calamia fruit", "some cactacae spine", "some sovyn clove", "some wolifrew lichen", "some woth flower", "some torban leaf" ]
         herb_list = herb_container.contents.find_all { |o| o.name == herb }
         total_doses = 0; herb_list.each { |h| total_doses += $useherbs_measure[h.id].to_i }
         if herb_list.any? { |h| $useherbs_measure[h.id].nil? } # assume any herb with an unkown count is good enough
            if total_doses > 0
               respond "#{herb.rjust(25)}: found (#{total_doses}+)"
            else
               respond "#{herb.rjust(25)}: found"
            end
            next
         end
         unless store_doses = $known_herbs.find { |h| h[:name] == herb }[:store_doses]
            echo "error: missing store_doses for #{herb}"
            next
         end
         if herb_list.empty?
            respond "#{herb.rjust(25)}: missing"
         else
            respond "#{herb.rjust(25)}: found (#{total_doses})"
            if (total_doses + store_doses) > 50
               next
            end
         end
         shopping_list.push(:herb_name => herb, :herb_list => herb_list, :needed => ((50-total_doses)/store_doses))
      end
      unless shopping_list.empty?
         respond
         respond "shopping list:"
         for thing in shopping_list
            respond "#{thing[:herb_name].rjust(25)} (#{thing[:needed]})"
         end
         respond
         sleep 2
         for thing in shopping_list
            unless done_gone_to_herbalist
               if check_silvers.call < 1500
                  withdraw.call
               end
               go_to_herbalist.call
               done_gone_to_herbalist = true
            end
            unless done_empty_hands
               empty_hands
               done_empty_hands = true
            end
            while old_herb = thing[:herb_list].shift
               dothistimeout "get ##{old_herb.id}", 5, get_regex
               if checkleft and checkright
                  bundle_result = dothistimeout 'bundle', 5, /^Carefully, you combine|^If you add anything more to this bundle|^You do not have anything to bundle!$/
               end
            end
            herb_type = $known_herbs.find { |h| h[:name] == thing[:herb_name] }[:type]
            thing[:needed].times {
               if buy_herb.call(herb_type)
                  if checkleft and checkright
                     bundle_result = dothistimeout 'bundle', 5, /^Carefully, you combine|^If you add anything more to this bundle|^You do not have anything to bundle!$/
                  end
               end
            }
            dothistimeout "put ##{GameObj.right_hand.id} in ##{herb_container.id}", 5, put_regex if checkright
            dothistimeout "put ##{GameObj.left_hand.id} in ##{herb_container.id}", 5, put_regex if checkleft
         end
      end
      fill_hands if done_empty_hands
   end
   deposit.call
   unless Room.current.id == start_room.id
      Script.run('go2', start_room.id.to_s)
   end
   exit
=begin
elsif script.vars[0] =~ /^inspect$/i
   if script.vars[2].nil?
      
   else

   end
   exit
=end
end

unless ([Wounds.head, Wounds.neck, Wounds.torso, Wounds.limbs, Wounds.nerves, Scars.head, Scars.neck, Scars.torso, Scars.limbs, Scars.nerves].max > 0) or ((checkhealth + 7) < maxhealth)
   respond
   respond 'Missing herb for Hypochondriasis.'
   respond
   exit
end

#
# set up
#
if script.vars.any? { |var| var =~ /^--buy(?:-missing)?=(on|off|true|false|yes|no)$/i }
   fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
   buy_missing = fix_option[$1]
   script.vars.delete_if { |var| var =~ /^--buy(?:-missing)?=(on|off|true|false|yes|no)$/i }
   script.vars[0] = script.vars[1..-1].join(' ')
end
if script.vars.any? { |var| var =~ /^--mending=(on|off|true|false|yes|no)$/i }
   fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
   use_mending = fix_option[$1]
   script.vars.delete_if { |var| var =~ /^--mending=(on|off|true|false|yes|no)$/i }
   script.vars[0] = script.vars[1..-1].join(' ')
end
if script.vars.any? { |var| var =~ /^(?:--)?no-?get$/i }
   no_get = true
   script.vars.delete_if { |var| var =~ /^(?:--)?no-?get$/i }
   script.vars[0] = script.vars[1..-1].join(' ')
else
   no_get = false
end
if script.vars[1]
   return_to_stow = true
   if script.vars[1] =~ /^(in|on|behind|under)$/i
      preposition = $1.downcase
      script.vars.delete_at(1)
      script.vars[0] = script.vars[1..-1].join(' ')
   else
      preposition = nil
   end
   if script.vars[1] =~ /^\#\-?[0-9]+$/
      herb_container = GameObj.new(script.vars[1].sub('#',''), '', '')
   elsif script.vars[1]
      unless herb_container = (GameObj.loot.find { |o| o.name =~ /#{script.vars[0]}/ } || GameObj.room_desc.find { |o| o.name =~ /#{script.vars[0]}/ })
         status_tags
         result = dothistimeout "look #{preposition || 'in'} #{script.vars[0]}", 5, /^<.*?>(In|On|Under|Behind) .*?exist="(\-?\d+)" noun="(.*?)">(.*?)<\/a/
         status_tags
         if result =~ /^<.*?>(In|On|Under|Behind) .*?exist="(\-?\d+)" noun="(.*?)">(.*?)<\/a/
            preposition = $1.downcase
            herb_container = GameObj.new($2, $3, $4)
         else
            echo "error: failed to find herb container (#{script.vars[0]})"
            exit
         end
      end
   elsif UserVars.herbsack.nil? or UserVars.herbsack.empty?
      echo "error: no herbsack set or specified on the command line"
      eixt
   else
      unless herb_container = (GameObj.inv.find { |obj| obj.noun == UserVars.herbsack } || GameObj.inv.find { |obj| obj.name == UserVars.herbsack } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.herbsack)}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{UserVars.herbsack.split(' ').collect { |n| Regexp.escape(n) }.join(".*\\b")}/i })
         echo "error: failed to find herb container"
         exit
      end
   end
   if preposition.nil?
      for prep in [ 'in', 'on', 'under', 'behind' ]
         look_result = dothistimeout "look #{prep} ##{herb_container.id}", 5, /(?:In|On|Under|Behind) .*? you see|There is nothing|^That is closed\.$|^What were you referring to\?|^I could not find what you were referring to\./
         if look_result =~ /^(?:In|On|Under|Behind) .*? you see/
            preposition = $1.downcase
            break
         elsif look_result =~ /^That is closed\./
            open_result = dothistimeout "open ##{herb_container.id}", 5, open_regex
            close_herbsack = true
            redo if open_result =~ /^You open/
         end
      end
      if preposition.nil?
         echo 'fixme'
         exit
      end
   end
   if herb_container.contents.nil?
      open_result = dothistimeout "open ##{herb_container.id}", 10, open_regex
      if open_result =~ /^You open/
         close_herbsack = true
      else
         dothistimeout "look #{preposition} ##{herb_container.id}", 10, /(?:In|On|Under|Behind) .*? you see|^There is nothing|^What were you referring to\?|^I could not find what you were referring to\./
         if herb_container.contents.nil?
            echo 'fixme 293743'
            exit
         end
      end
   end
else
   if UserVars.herbsack.nil? or UserVars.herbsack.empty?
      echo 'no container was given and herbsack is not set'
      echo '  use  ;useherbs set herbsack <container name>'
      echo '  or   ;useherbs <in|on|behind|under> <container name>'
      exit
   end

   unless herb_container = (GameObj.inv.find { |obj| obj.noun == UserVars.herbsack } || GameObj.inv.find { |obj| obj.name == UserVars.herbsack } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.herbsack)}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{UserVars.herbsack.split(' ').collect { |n| Regexp.escape(n) }.join(".*\\b")}/i })
      echo "error: unable to find container \"#{UserVars.herbsack}\" in your inventory."
      exit
   end

   if herb_container.contents.nil?
      open_result = dothistimeout "open ##{herb_container.id}", 10, open_regex
      if open_result =~ /^You open/
         close_herbsack = true
      else
         dothistimeout "look in ##{herb_container.id}", 10, /In the .*? you see/
         if herb_container.contents.nil?
            echo 'fixme 38923'
            exit
         end
      end
   end
end

empty_hand

#
# use herbs
#
while herb_type = next_herb_type.call
   if $known_herbs.any? { |h| h[:type] == herb_type and (h[:name] == GameObj.right_hand.name or (h[:short_name] and h[:short_name] == GameObj.right_hand.name)) }
      herb = GameObj.right_hand
   elsif $known_herbs.any? { |h| h[:type] == herb_type and (h[:name] == GameObj.left_hand.name or (h[:short_name] and h[:short_name] == GameObj.left_hand.name)) }
      herb = GameObj.left_hand
   elsif [Wounds.leftArm, Wounds.rightArm].min < 3
      if return_to_stow and start_room.id != Room.current.id
         Script.run('go2', start_room.id.to_s)
         dothistimeout "look #{preposition} ##{herb_container.id}", 4, /(?:In|On|Under|Behind) .*? you see|^There is nothing|^What were you referring to\?|^I could not find what you were referring to\./
      end
      if herb_container.contents.nil?
         dothistimeout "look #{preposition} ##{herb_container.id}", 4, /(?:In|On|Under|Behind) .*? you see|^There is nothing|^What were you referring to\?|^I could not find what you were referring to\./
      end
      if herb = herb_container.contents.find { |i| $known_herbs.find { |h| (h[:name] == i.name) and h[:type] == herb_type } }
         stow_herb.call
         unless no_get and (herb.name !~ drinkable)
            get_result = dothistimeout "get ##{herb.id}#{get_from}", 5, get_regex
            if (get_result =~ /^Get what/) and get_from.nil?
               get_from = " from ##{herb_container.id}"
               redo
            elsif get_result.nil? or (get_result == 'Get what?') or (get_result == "Why don't you leave some for others?")
               echo 'fixme 4'
               exit
            elsif (get_result =~ /^You need a free hand for that\.|^You need a free hand to pick that up\./) and (!checkright or !checkleft)
               herb = nil
            end
         end
      end
   end
   if buy_missing and not herb
      stow_herb.call
      unless silvers
         silvers = check_silvers.call
      end
      unless silvers > 4000
         withdraw.call
      end
      unless Room.current.tags.include?('herbalist')
         go_to_herbalist.call
      end
      unless herb_shop_menu
         herb_shop_menu = read_menu.call
      end
      herb_name = herb_shop_menu.keys.find { |name| $known_herbs.any? { |h| (h[:type] == herb_type) and (name =~ /#{h[:name]}/ or name =~ /#{h[:name].sub(/sticky |gooey | green| fragrant| shiny| dirty/, '')}/) } }
      unless order_number = herb_shop_menu[herb_name]
         echo "error: failed to find a herb for #{herb_type} in the menu"
         buy_missing = false
      end
      dothistimeout "order #{order_number}", 3, /BUY/
      buy_result = dothistimeout 'buy', 3, /Sold for [0-9]+ silver|^But you do not have enough silver!/
      if buy_result =~ /Sold for ([0-9]+) silver/
         silvers -= $1.to_i
      elsif buy_result =~ /^But you do not have enough silver!/
         withdraw.call
         go_to_herbalist.call
         redo
      else
         silvers = check_silvers.call
      end
      if $known_herbs.any? { |info| info[:name] =~ /#{checkright}/ }
         herb = GameObj.right_hand
      elsif $known_herbs.any? { |info| info[:name] =~ /#{checkleft}/ }
         herb = GameObj.left_hand
      else
         echo 'fixme: 6'
         buy_missing = false
      end
   end
   if herb
      if use_mending and (mending = Spell[9713]) and !mending.active? and mending.known? and mending.affordable?
         mending.cast
      end
      used_herbs.push(herb.id) unless used_herbs.include?(herb.id)
      if herb.name =~ drinkable
         use_cmd = "drink ##{herb.id}"
      else
         use_cmd = "eat ##{herb.id}"
      end
      use_result = dothistimeout use_cmd, 5, /^You (?:manage to )?take a (?:bite|drink)/
      if use_result.nil?
         echo 'fixme 5'
         exit
      else
         sleep 0.5
         waitrt?
      end
   else
      if herb_type =~ /head/
         skippable.push 'head'
         skippable.push 'neck'
      elsif herb_type =~ /organ|missing eye/
         skippable.push 'torso'
      elsif herb_type =~ /limb/
         skippable.push 'limbs'
      elsif herb_type =~ /nerve/
         skippable.push 'nerves'
      elsif herb_type == 'blood'
         skippable.push 'blood'
      else
         skippable.push herb_type
      end
      respond "\nMissing herb for #{herb_type}.\n\n   #{$known_herbs.find_all { |h| h[:type] == herb_type }.collect { |h| h[:name] }.join(', ')}\n\n"
   end
end

#
# clean up
#
stow_herb.call
fill_hand
dothistimeout "close ##{herb_container.id}", 5, close_regex if close_herbsack
deposit.call
unless Room.current.id == start_room.id
   Script.run('go2', start_room.id.to_s)
end
