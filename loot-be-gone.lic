=begin

	This script gets rid of your loot.

	gives heirlooms to a guard
	gives bounty herbs to herbalist if the id's of the herbs are in the array $bounty_herbs
	opens boxes (off by default)
	bunldes herbs (off by default)
	gives gold rings to the chronomage
	stockpiles gems into jars in your locker (off by default)
	gets gems from the stockpile for bounties (only if you have enough to complete the bounty)
	saves scrolls that have spells you choose (list is empty by default)
	appraise various types of items that you choose, and saves them if they're expensive
	might possibly avoid selling gems and skins that you have a bounty for in the wrong town
	sells stuff
	deposits monies

	;loot-be-gone help

	https://github.com/matt-lowe/lich-scripts
	tillmen@lichproject.org

=end

if defined?(GameObj.type_data)
	GameObj.load_data if GameObj.type_data.empty? or GameObj.type_data.nil?
	if GameObj.type_data.nil?
		wait_while { running?('updater') }
		wait_while { running?('repository') }
		start_script 'repository', [ 'download', 'gameobj-data.xml' ]
		wait_while { running?('repository') }
		wait_while { running?('updater') }
		start_script 'updater', [ 'add', 'gameobj-data.xml' ]
		wait_while { running?('updater') }
		GameObj.load_data
		exit if GameObj.type_data.nil?
	end
end

silence_me

withdraw_amount = 8000
save_value = { 'gemshop' => 15000, 'pawnshop' => 35000 }

$loot_be_gone_ignore ||= Array.new
need_close_lootsack    = Hash.new

save_herb_list       = [ 'some torban leaf', 'some basal moss', 'some acantha leaf', 'some ambrominas leaf', 'some cactacae spine', 'some aloeas stem', 'some haphip root', 'some pothinir grass', 'some ephlox moss', 'some calamia fruit', 'some sovyn clove', 'some wolifrew lichen', 'some woth flower' ]
save_one_potion_list = [ 'white flask', 'bur-clover potion' ]
save_two_potion_list = [ 'rose-marrow potion', 'brostheras potion', 'wingstem potion', 'talneo potion', 'bolmara potion' ]

herbalist_rooms = [ 3824, 1851, 10396, 640, 5722, 2406 ]

CharSettings['keep scrolls'] = Array.new unless CharSettings['keep scrolls'].class == Array
CharSettings['exclude types'] = 'weapon|armor|scroll' if CharSettings['exclude types'].nil?
CharSettings['appraise types'] = 'jewelry|weapon|armor|uncommon' if CharSettings['appraise types'].nil?
CharSettings['chronomage'] = true if CharSettings['chronomage'].nil?
notes = Array.new

if script.vars[1] =~ /^stockpile=(on|off|yes|no|true|false|forget)$/
	if $1 == 'forget'
		CharSettings[:jars] = nil
		echo 'stockpile tracking cleared'
	else
		fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
		CharSettings['stockpile'] = fix_option[$1]
		echo 'setting saved'
	end
	exit
elsif script.vars[1] =~ /^locker=([0-9]+|nil)$/
	if $1 == 'nil'
		CharSettings['locker'] = nil
	else
		CharSettings['locker'] = $1
	end
	echo 'setting saved'
	exit
elsif script.vars[1] =~ /^open(?:\-boxes)?=(on|off|yes|no|true|false)$/
	fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
	CharSettings['open boxes'] = fix_option[$1]
	echo 'setting saved'
	exit
elsif script.vars[1] =~ /^bundle(?:\-herbs)?=(on|off|yes|no|true|false)$/
	fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
	CharSettings['bundle herbs'] = fix_option[$1]
	echo 'setting saved'
	exit
elsif script.vars[1] =~ /^chronomage=(on|off|yes|no|true|false)$/
	fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
	CharSettings['chronomage'] = fix_option[$1]
	echo 'setting saved'
	exit
elsif script.vars[1] =~ /^trash(?:\-herbs)?=(on|off|yes|no|true|false)$/
	fix_option = { 'on' => true, 'true' => true, 'yes' => true, 'off' => false, 'false' => false, 'no' => false }
	CharSettings['trash herbs'] = fix_option[$1]
	echo 'setting saved'
	exit
elsif script.vars[1] =~ /^(?:herb\-)?drop(?:\-room)?=(.+)$/
	if $1 == 'nil'
		CharSettings['herb drop room'] = nil
	else
		CharSettings['herb drop room'] = $1
	end
	echo 'setting saved'
	exit
elsif script.vars[0] =~ /^exclude-names=(.+)$/
	var = $1
	if var == 'nil'
		CharSettings['exclude regex'] = false
	else
		begin
			Regexp.new(var)
		rescue
			echo "error: #{$!}"
			echo 'ignoring setting'
			exit
		end
		CharSettings['exclude regex'] = var
	end
	echo 'setting saved'
	exit
elsif script.vars[0] =~ /^exclude\-types=(.+)$/
	var = $1
	if var == 'nil'
		CharSettings['exclude types'] = false
	else
		begin
			Regexp.new(var)
		rescue
			echo "error: #{$!}"
			echo 'ignoring setting'
			exit
		end
		CharSettings['exclude types'] = var
	end
	echo 'setting saved'
	exit
elsif script.vars[0] =~ /^appraise\-types=(.+)$/
	var = $1
	if var == 'nil'
		CharSettings['appraise types'] = false
	else
		begin
			Regexp.new(var)
		rescue
			echo "error: #{$!}"
			echo 'ignoring setting'
			exit
		end
		CharSettings['appraise types'] = var
	end
	echo 'setting saved'
	exit
elsif script.vars[1] =~ /^(?:keep\-)?scrolls=(.+)$/
	option = $1
	if option.downcase == 'nil'
		CharSettings['keep scrolls'] = Array.new
		echo 'setting saved'
	elsif option =~ /^[0-9,]+$/
		CharSettings['keep scrolls'] = option.split(',').collect { |num| num.to_i }
		echo 'setting saved'
	else
		echo "You're doing it wrong."
	end
	exit
elsif script.vars[1] =~ /list/
	if script.vars[2] =~ /stockpile/
		output = "                           gem count  full\n"
		output.concat "                           --- -----  ----\n"
		for jar in CharSettings[:jars].sort { |a,b| b[:count] <=> a[:count] }
			output.concat "#{jar[:gem].rjust(30)} #{jar[:count].to_s.rjust(2)} #{jar[:full].to_s.rjust(8)}\n"
		end
		respond output
	else
		fix_option = { true => 'on', false => 'off', nil => 'off' }
		output = "\n"
		output.concat "     stockpile: #{fix_option[CharSettings['stockpile']]}\n"
		output.concat "        locker: #{CharSettings['locker'] || 'nil'}\n"
		output.concat "    open-boxes: #{fix_option[CharSettings['open boxes']]}\n"
		if CharSettings['keep scrolls'].empty?
			output.concat "  keep-scrolls: (none)\n"
		else
			output.concat "  keep-scrolls: #{CharSettings['keep scrolls'].join(',')}\n"
		end
		output.concat "  bundle-herbs: #{fix_option[CharSettings['bundle herbs']]}\n"
		output.concat "   trash-herbs: #{fix_option[CharSettings['trash herbs']]}\n"
		output.concat "    chronomage: #{fix_option[CharSettings['chronomage']]}\n"
		output.concat "herb-drop-room: #{CharSettings['herb drop room'] || '(none)'}\n"
		output.concat "\n"
		output.concat " exclude-names: #{CharSettings['exclude regex'] || '(none)'}\n"
		output.concat "\n"
		output.concat " exclude-types: #{CharSettings['exclude types'] || '(none)'}\n"
		output.concat "\n"
		output.concat "appraise-types: #{CharSettings['appraise types'] || '(none)'}\n"
		output.concat "\n"
		output.concat "      lootsack: #{UserVars.lootsack || '(none)'}\n"
		lootsack_num = 2
		while (UserVars.send("lootsack#{lootsack_num}").class == String) and not UserVars.send("lootsack#{lootsack_num}").empty?
			output.concat "     lootsack#{lootsack_num}: #{UserVars.send("lootsack#{lootsack_num}")}\n"
			lootsack_num += 1
		end
		output.concat "\n"
		respond output
	end
	exit
elsif not script.vars[1].nil?
	output = "\n"
	output.concat "   #{$clean_lich_char}#{script.name} list                           Shows current settings.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} list stockpile                 Shows stockpile contents.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} stockpile=<on|off>             Stockpile gems in jars in your locker, and retrieve and sell them\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                when you have a gem bounty.\n"
	output.concat "   #{$clean_lich_char}#{script.name} locker=<room number>           Room number of the room with a curtain or opening to get to your locker.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} stockpile=forget               Clears the tracking info for the jars in your locker.  Needed\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                if you manually add or remove gems or jars from your locker.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} open-boxes=<on|off>            Uses the town npc locksmith to open boxes before selling.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} keep-scrolls=nil               Sell scrolls without reading them.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} keep-scrolls=<#,#,#>           Read scrolls and save them only if they have a spell that's in the\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                given comma separated list. (Use exclude-types to save all scrolls.)\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} bundle-herbs=<on|off>          Bundles herbs commonly found in the loot system with those\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                found in your herbsack.  Keeps only one full bundle or two\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                full potions of each type, and drops the rest.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} trash-herbs=<on|off>           Throw away herbs found in boxes\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} herb-drop-room=<room number>   Sets the room where extra herbs will be dropped.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} herb-drop-room=<varname>       If <varname> is \"rest_room\", the script will look up the drop\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                room from rest_room as shown in the ;settings command.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} herb-drop-room=nil             Clears the setting.  Extra herbs will be dropped where ever you\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                happen to be standing (could be the room the script was started\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                in, the locksmith, the herbalist, or the town guard)\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} chronomage=<on|off>            Give gold rings to the chronomage.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} types=<regex>                  Only sell items whose type matches the given regex. (does not\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                stop items marked as new loot from being sold or dropped)\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} exclude-names=<regex>          Any item names matching the given regex will not be sold.\n"
	output.concat "   #{$clean_lich_char}#{script.name} exclude-names=nil              Clears the setting.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} exclude-types=<regex>          Any item type matching the given regex will not be sold.\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                Meaningful types will change as gameobj-data.xml changes, but\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                here's a random list: gem, skin, reagent, jewelry, magic, uncommon,\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                herb, food, weapon, armor, clothing, alchemy product, cursed\n"
	output.concat "   #{$clean_lich_char}#{script.name} exclude-types=nil              Clears the setting.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}#{script.name} appraise-types=<regex>         Any item type matching the given regex will be appraised first,\n"
	output.concat "   #{''.rjust($clean_lich_char.length)}#{''.rjust(script.name.length)}                                and saved if it's expensive.\n"
	output.concat "   #{$clean_lich_char}#{script.name} appriase-types=nil             Clears the setting.\n"
	output.concat "\n"
	output.concat "   #{$clean_lich_char}set change lootsack <container>\n"
	output.concat "   #{$clean_lich_char}set change lootsack2 <container>\n"
	output.concat "   #{$clean_lich_char}set change lootsack<num> <container>\n"
	respond output
	exit
end

lootsack_list = Array.new
lootsack_num = nil
while (UserVars.send("lootsack#{lootsack_num}").class == String) and not UserVars.send("lootsack#{lootsack_num}").empty?
	if lootsack = GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.send("lootsack#{lootsack_num}").strip)}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.send("lootsack#{lootsack_num}")).sub(' ', ' .*')}$/i } || GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.send("lootsack#{lootsack_num}")).sub(' ', ' .*')}/i }
		lootsack_list.push(lootsack)
	else
		echo "warning: failed to find lootsack#{lootsack_num} (#{UserVars.send("lootsack#{lootsack_num}")})"
	end
	lootsack_num = 1 if lootsack_num.nil?
	lootsack_num += 1
end
if lootsack_list.empty?
	echo 'error: no lootsacks found' 
	exit
end

for lootsack in lootsack_list
	if lootsack.contents.nil?
		open_result = dothistimeout "open ##{lootsack.id}", 5, /^You open|^That is already open\.$/
		if open_result =~ /^You open/
			need_close_lootsack.push(lootsack.id)
		else
			dothistimeout "look in ##{lootsack.id}", 5, /In .*? you see/
			if lootsack.contents.nil?
				echo 'error: failed to find lootsack contents'
				exit
			end
		end
	end
end

lootsack_put = proc { |obj|
	for lootsack in lootsack_list
		result = dothistimeout "_drag ##{obj.id} ##{lootsack.id}", 4, /^You put|^You need a free hand to pick that up\.|It's closed!|^Your .*? won't fit in .*?\.$|^I could not find what you were referring to\.|^Do you want to put that in or on/
		break unless result =~ /won't fit/
	end
}

if CharSettings['bundle herbs']
	if UserVars.herbsack.nil? or UserVars.herbsack.empty?
		echo 'herbsack is not set. (;set change herbsack <container name>)'
		exit
	end
	unless herbsack = (GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(UserVars.herbsack.strip)}$/i } || GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(UserVars.herbsack).sub(' ', ' .*')}$/i })
		echo 'error: failed to find your herbsack'
		exit
	end
end

check_silvers = proc {
	silvers = nil
	action = proc { |server_string|
		if server_string =~ /^\s*Name\:|^\s*Gender\:|^\s*Normal \(Bonus\)|^\s*Strength \(STR\)\:|^\s*Constitution \(CON\)\:|^\s*Dexterity \(DEX\)\:|^\s*Agility \(AGI\)\:|^\s*Discipline \(DIS\)\:|^\s*Aura \(AUR\)\:|^\s*Logic \(LOG\)\:|^\s*Intuition \(INT\)\:|^\s*Wisdom \(WIS\)\:|^\s*Influence \(INF\)\:/
			nil
		elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9]+)/
			silvers = $1.to_i
			DownstreamHook.remove("#{script.name}_check_silvers")
			nil
		else
			server_string
		end
	}
	DownstreamHook.add("#{script.name}_check_silvers", action)
	save_silent = script.silent
	script.silent = true
	put 'info'
	script.silent = save_silent
	wait_until { silvers }
	silvers
}

need_to_open_boxes = proc {
	need = true
	unless (GameObj.right_hand.type =~ /box/) or (GameObj.left_hand.type =~ /box/) or lootsack_list.any? { |lootsack| lootsack.contents.find { |obj| obj.type =~ /box/ } }
		unless disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk$/ }
			if reget.any? { |line| line =~ /^Your disk arrives, following you dutifully\.\r?$/ }
				50.times { break if GameObj.loot.any? { |obj| obj.name =~ /#{Char.name} disk$/ }; sleep 0.1 }
				disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk$/ }
			end
		end
		if disk and disk.contents.nil?
			dothistimeout "look in ##{disk.id}", 2, /^In the|^There is nothing in there\.$/
		end
		unless disk.contents.any? { |obj| obj.type =~ /box/ }
			need = false
		end
	end
	need
}

table = activator = trash = nil
open_box = proc { |box|
	unless (GameObj.right_hand.id == box.id) or (GameObj.left_hand.id == box.id)
		dothistimeout "get ##{box.id}", 3, /^You remove|^Get what\?$/
	end
	if (GameObj.right_hand.id == box.id) or (GameObj.left_hand.id == box.id)
		fput 'unhide' if invisible?
		activator_result = dothistimeout activator, 5, /^You .*? the .*? but .*? ignores you|I'm afraid that you can't pull that.|^You .*? the .*?, and ask .*?/
		if activator_result =~ /^You .*? the .*? but .*? ignores you/
			dothistimeout "drop ##{box.id}", 3, /flickers in and out of existence|^You drop/
			dothistimeout "get ##{box.id}", 3, /^You already|^You pick up/
			activator_result = dothistimeout activator, 5, /^You .*? the .*? but .*? ignores you|I'm afraid that you can't pull that.|^You .*? the .*?, and ask .*?/
		end
		if activator_result =~ /^You .*? the .*?, and ask .*?|^You .*? the .*? but .*? ignores you/
			if activator_result =~ /^You .*? the .*? but .*? ignores you/
				pay_result = 'accepts your silvers'
			else
				pay_result = dothistimeout 'pay', 5, /^But you don't have enough!|accepts your silvers/
			end
			if pay_result =~ /accepts your silvers/
				open_result = dothistimeout "open ##{box.id}", 5, /^You open|^That is already open\.|^It appears to be locked\./
				if open_result =~ /^You open|^That is already open\./
					get_result = dothistimeout "get coins from ##{box.id}", 5, /^You gather the remaining|^Get what\?/
					unless get_result =~ /^You gather the remaining/
						echo 'fixme (9)'
					end
					waitrt?
					drop_box = false
					for obj in box.contents
						if obj.type =~ /cursed/
							drop_box = true
							next
						elsif (obj.type =~ /junk|food/) or (CharSettings['trash herbs'] and obj.type =~ /herb/)
							if trash
								dothistimeout "get ##{obj.id}", 3, /^You/
								dothistimeout "put ##{obj.id} in ##{trash.id}", 3, /^You put|^As you place/
							else
								dothistimeout "_drag ##{obj.id} drop", 3, /^You drop/
							end
						else
							lootsack_put.call(obj)
						end
					end
					if drop_box
						dothistimeout "drop ##{box.id}", 3, /^You drop/
					else
						unless box.contents.empty?
							echo 'error: box is not empty'
							lootsack_put.call(box)
						end
						if trash
							dothistimeout "put ##{box.id} in ##{trash.id}", 3, /^You put|^As you place/
						else
							dothistimeout "drop ##{box.id}", 3, /^You drop/
						end
					end
					sleep 0.1
				elsif open_result =~ /^It appears to be locked\./
					echo 'fixme (2382)'
				else
					echo 'fixme (8)'
				end
			elsif pay_result =~ /^But you don't have enough!/
				start_script 'go2', [ 'bank', '--disable-confirm' ]
				wait_while { running?('go2') }
				fput "withdraw #{withdraw_amount} silvers"
				start_script 'go2', [ 'locksmith', '--disable-confirm' ]
				wait_while { running?('go2') }
				open_box.call(box)
			else
				echo 'fixme (6)'
			end
		else
			echo 'fixme (5)'
		end
	else
		echo 'fixme (3)'
	end
}

to_locker = proc {
	silvers = check_silvers.call
	if silvers < 526
		start_script 'go2', [ 'bank', '--disable-confirm' ]
		wait_while { running?('go2') }
		fput 'unhide' if invisible?
		fput "withdraw #{526 - silvers}"
	end
	start_script 'go2', [ CharSettings['locker'] ]
	wait_while { running?('go2') }
	if way_in = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain)$/ }
		move "go #{way_in.noun}"
	else
		false
	end
}

from_locker = proc {
	if way_out = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain)$/ }
		move "go #{way_out.noun}"
	end
}

need_to_stockpile = proc {
	if CharSettings[:jars].any? { |jar| jar[:gem] =~ /large|medium|small|tiny/ }
		CharSettings[:jars] = nil
	end
	can_start_new_jar = (CharSettings[:empty_jar_count] > 0) && lootsack_list.any? { |lootsack| lootsack.contents.any? { |obj| (obj.type =~ /gem/) and (obj.name !~ /oblivion quartz$/) and not CharSettings[:jars].any? { |jar| jar[:gem] =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').sub(/x\b/, 'xe?').gsub(/\b\s/, 's? ')}s?$/ } } }
	can_add_to_jar = CharSettings[:jars].any? { |jar| 
		!jar[:full] && lootsack_list.any? { |lootsack| 
			lootsack.contents.any? { |obj|
				jar[:gem] =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').sub(/x\b/, 'xe?').gsub(/\b\s/, 's? ')}s?$/ 
			} 
		}
	}
	CharSettings[:jars].nil? || can_start_new_jar || can_add_to_jar
}

need_to_raid_stockpile = proc {
	if checkbounty =~ /gem dealer.* requesting (?:a|an|some) (.*?)\. .* retrieve ([0-9]+) (?:more )?of them\./
		gem = $1
		count = $2.to_i
		if checkbounty =~ /(Wehnimer's Landing|Icemule Trace|Solhaven|Kharam\-Dzu|Zul Logoth|River's Rest|Ta'Illistim|Ta'Vaalor)/
			target_town = $1
			gemshop = Room[Room[CharSettings['locker']].find_nearest_by_tag('gemshop')]
			if gemshop.location and (gemshop.location =~ /Wehnimer's Landing|Icemule Trace|Solhaven|Kharam\-Dzu|Zul Logoth|River's Rest|Ta'Illistim|Ta'Vaalor/) and (gemshop.location !~ /#{target_town}/)
				false
			else
				CharSettings[:jars].any? { |jar| (jar[:gem] =~ /^#{gem.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').sub(/x\b/, 'xe?').gsub(/\b\s/, 's? ')}s?$/) and (jar[:count] >= count) }
			end
		else
			CharSettings[:jars].any? { |jar| (jar[:gem] =~ /^#{gem.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').sub(/x\b/, 'xe?').gsub(/\b\s/, 's? ')}s?$/) and (jar[:count] >= count) }
		end
	else
		false
	end
}

stockpile = proc {
	status_tags
	open_result = dothistimeout 'open locker', 5, /exist=".*?" noun="(?:locker|chest)"/
	status_tags
	if open_result =~ /exist="(\d+)" noun="(locker|chest)"/
		locker_id = $1
		locker_contents = GameObj.containers[locker_id]
		unless locker_contents
			dothistimeout "look in ##{locker_id}", 3, /^In the/
			locker_contents = GameObj.containers[locker_id]
		end
		if locker_contents
			if CharSettings[:jars].nil?
				CharSettings[:jars] = Array.new
				CharSettings[:empty_jar_count] = 0
				locker_contents.find_all { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ }.each { |jar|
					if jar.after_name.nil?
						CharSettings[:empty_jar_count] = CharSettings[:empty_jar_count] + 1
					else
						look_result = dothistimeout "look in ##{jar.id} from ##{locker_id}", 3, /^Inside .*? you see [0-9]+ portion/
						if look_result =~ /^Inside .*? you see ([0-9]+) portion/
							count = $1.to_i
							gem = jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, '')
							full = look_result.include?('It is full')
							CharSettings[:jars].push(h={ :gem => gem, :count => count, :full => full })
						end
					end
				}
			end
			empty_hands
			not_suitable = Array.new
			for jar in locker_contents.find_all { |obj| obj.noun =~ /^(?:jar|beaker|bottle)$/ }
				if jar.after_name =~ /^containing /
					gem_list = Array.new
					lootsack_list.each { |lootsack| gem_list.concat(lootsack.contents.find_all { |obj| (jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, '') =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').sub(/x\b/, 'xe?').gsub(/\b\s/, 's? ')}s?$/) }) }
					gem_list.delete_if { |obj| not_suitable.include?(obj.id) }
					jar_hash = CharSettings[:jars].find { |j| j[:gem] == jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, '') }
					unless gem_list.empty? or jar_hash[:full]
						dothistimeout "get ##{jar.id} from ##{locker_id}", 3, /^You remove/
						for gem in gem_list
							result = dothistimeout "_drag ##{gem.id} ##{jar.id}", 3, /^You add|is full|does not appear to be a suitable container for/
							if result =~ /^You add .* filling it/
								jar_hash[:count] = jar_hash[:count] + 1
								jar_hash[:full] = true
							elsif result =~ /^You add/
								jar_hash[:count] = jar_hash[:count] + 1
							elsif result =~ /is full/
								jar_hash[:full] = true
								lootsack_put.call(gem)
								break
							elsif result =~ /does not appear to be a suitable container for/
								not_suitable.push(gem.id)
								lootsack_put.call(gem)
							else
								lootsack_put.call(gem)
							end
						end
						dothistimeout "put ##{jar.id} in ##{locker_id}", 3, /^You (?:put|place)/
					end
				else
					gem_count = Hash.new
					lootsack_list.each { |lootsack|
						lootsack.contents.each { |obj|
							if (obj.type =~ /gem/) and (obj.name !~ /oblivion quartz$/) and not locker_contents.any? { |o| o.after_name.gsub(/^containing |large |medium |small |tiny |some /, '') =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').sub(/x\b/, 'xe?').gsub(/\b\s/, 's? ')}s?$/ and not not_suitable.include?(obj.id) }
								gem_count[obj.name.gsub(/large |medium |small |tiny |some /, '')] = gem_count[obj.name.gsub(/large |medium |small |tiny |some /, '')].to_i + 1
							end
						}
					}
					next if gem_count.empty?
					gem_name = nil
					gem_num = 0
					gem_count.each_pair { |name,num|
						if num > gem_num
							gem_name = name
							gem_num = num
						end
					}
					dothistimeout "get ##{jar.id} from ##{locker_id}", 3, /^You remove/
					jar_hash = nil
					lootsack_list.each { |lootsack|
						lootsack.contents.each { |obj|
							if obj.name.gsub(/large |medium |small |tiny |some /, '') == gem_name
								result = dothistimeout "_drag ##{obj.id} ##{jar.id}", 3, /^You (?:add|put)|is full|does not appear to be a suitable container for/
								if result =~ /^You put/
									dothistimeout "put ##{jar.id} in ##{lootsack.id}", 3, /^You put/
									gem = lootsack.contents.find { |obj| obj.id == jar.id }.after_name.gsub(/^containing |large |medium |small |tiny |some /, '')
									dothistimeout "get ##{jar.id}", 3, /^You remove/
									jar_hash = { :gem => gem, :count => 1, :full => false }
									CharSettings[:jars].push(jar_hash)
								elsif result =~ /^You add/
									jar_hash[:count] = jar_hash[:count] + 1
								elsif result =~ /is full/
									dothistimeout "put ##{obj.id} in ##{lootsack.id}", 3, /^You put/
									jar_hash[:full] = true
									break
								elsif result =~ /does not appear to be a suitable container for/
									not_suitable.push(obj.id)
									dothistimeout "put ##{obj.id} in ##{lootsack.id}", 3, /^You put/
								end
							end
						}
					}
					dothistimeout "put ##{jar.id} in ##{locker_id}", 3, /^You (?:put|place)/
				end
			end
			dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
			fill_hands
		else
			dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
			echo 'error: failed to find locker contents'
		end
	else
		dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
		echo 'error: failed to find locker'
	end
}

raid_stockpile = proc {
	if bounty? =~ /gem dealer .* requesting (?:a|an|some) (.*?)\. .* retrieve ([0-9]+) (?:more )?of them\./
		gem = $1
		count = $2.to_i
		gem.gsub!(/large |medium |small |tiny |some /, '')
		status_tags
		open_result = dothistimeout 'open locker', 5, /exist=".*?" noun="(?:locker|chest)"/
		status_tags
		if open_result =~ /exist="(\d+)" noun="(locker|chest)"/
			locker_id = $1
			locker_contents = GameObj.containers[locker_id]
			unless locker_contents
				dothistimeout "look in ##{locker_id}", 3, /^In the/
				locker_contents = GameObj.containers[locker_id]
			end
			if locker_contents
				if CharSettings[:jars].any? { |jar| (jar[:gem] =~ /^#{gem.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').sub(/x\b/, 'xe?').gsub(/\b\s/, 's? ')}s?$/) and (jar[:count] >= count) }
					if jar = locker_contents.find { |jar| jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, '') =~ /^#{gem.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').sub(/x\b/, 'xe?').gsub(/\b\s/, 's? ')}s?$/ }
						jar_hash = CharSettings[:jars].find { |j| j[:gem] == jar.after_name.sub(/^containing |large |medium |small |tiny |some /, '') }
						empty_hands
						dothistimeout "get ##{jar.id} from ##{locker_id}", 3, /^You remove/
						count.times {
							dothistimeout "shake ##{jar.id}", 3, /^You .*shake/
							if GameObj.right_hand.id != jar.id
								obj = GameObj.right_hand
							elsif GameObj.left_hand.id != jar.id
								obj = GameObj.left_hand
							end
							lootsack_put.call(obj)
							jar_hash[:count] = jar_hash[:count] - 1
							jar_hash[:full] = false
						}
						dothistimeout "put ##{jar.id} in ##{locker_id}", 3, /^You (?:put|place)/
						if jar_hash[:count] < 1
							CharSettings[:jars].delete(jar_hash)
							CharSettings[:empty] = CharSettings[:empty] + 1
						end
						fill_hands
						dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
						true
					else
						dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
						false
					end
				else
					dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
					false
				end
			else
				dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
				echo 'error: failed to find locker contents'
				false
			end
		else
			dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
			echo 'error: failed to find locker'
			false
		end
	else
		echo "error: you're doing it wrong"
		false
	end
}

# this variable isn't used anymore, but loot.lic is probably still adding to it, so clear it before it gets out of control
$new_loot = Array.new

did_something = false

if bounty? =~ /You have located the heirloom/
	did_something = true
	start_script 'go2', [ 'advguard', '--disable-confirm' ]
	wait_while { running?('go2') }
	unless (guard = GameObj.npcs.find { |npc| npc.noun.downcase =~ /^(?:guard|vontrilaias|syllardeth|arnlis|dukash|simlasyth|gaelthar|sergeant|guardsman)$/ }) or (checkroom == "[River's Rest, Purser's Office]")
		start_script 'go2', [ 'advguard2', '--disable-confirm' ]
		wait_while { running?('go2') }
		guard = GameObj.npcs.find { |npc| npc.noun.downcase =~ /^(?:guard|vontrilaias|syllardeth|arnlis|dukash|simlasyth|gaelthar|sergeant|guardsman)$/ }
	end
	if guard or (checkroom == "[River's Rest, Purser's Office]")
		for lootsack in lootsack_list
			for item in lootsack.contents
				look_result = dothistimeout "look ##{item.id}", 3, /^Engraved .* initials|^You see nothing unusual\.$|^The ring appears|^It takes you a moment|^It is difficult to see/
				if look_result =~ /^Engraved .* initials/
					fput 'unhide' if invisible?
					empty_hands
					fput "get ##{item.id}"
					if guard
						result = dothistimeout "give ##{guard.id}", 3, /I shall inform the Adventurer's Guild that you successfully completed your task|The guard is in no condition to receive your offer!/
						if result =~ /The guard is in no condition to receive your offer!/
							fput "put ##{item.id} in ##{lootsack.id}"
						end
					else
						fput "give purser"
					end
					fill_hands
					break
				end
			end
		end
	end
end

$bounty_herbs ||= Array.new
unless $bounty_herbs.empty?
	did_something = true
	target = Room.current.find_nearest(herbalist_rooms)
	start_script 'go2', [ target.to_s ]
	wait_while { running?('go2') }
	empty_hands
	for herb_id in $bounty_herbs
		fput "get ##{herb_id}"
		if herb = [ GameObj.right_hand, GameObj.left_hand ].find { |obj| obj.id == herb_id }
			fput 'unhide' if invisible?
			fput "give #{GameObj.npcs.last.noun}"
			25.times { break unless checkright; sleep 0.1 }
			lootsack_put.call(herb) if checkright
		end
	end
	fill_hands
	$bounty_herbs.clear
end

if CharSettings['open boxes'] and need_to_open_boxes.call
	did_something = true
	silvers = check_silvers.call
	if silvers < withdraw_amount
		start_script 'go2', [ 'bank', '--disable-confirm' ]
		wait_while { running?('go2') }
		fput 'unhide' if invisible?
		fput "withdraw #{withdraw_amount - silvers} silvers"
	end
	start_script 'go2', [ 'locksmith', '--disable-confirm' ]
	wait_while { running?('go2') }
	unless trash = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.noun =~ /^(?:crate|barrel|wastebarrel|casket)$/ } || trash = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.noun == 'coffer' }
		echo 'warning: failed to find a trash container'
	end
	if table = (GameObj.room_desc.to_a + GameObj.loot.to_a).find { |obj| obj.noun =~ /^(?:table|counter)$/ }
		if table.contents.nil?
			dothistimeout "look on ##{table.id}", 5, /On the .*? you see/
			if not table.contents.nil?
				activator = nil
				if table.contents.any? { |obj| obj.noun == 'bell' }
					activator = 'ring bell'
				elsif table.contents.any? { |obj| obj.noun == 'keys' }
					activator = 'pull keys'
				elsif table.contents.any? { |obj| obj.noun == 'chime' } or GameObj.loot.any? { |obj| obj.noun == 'chime' }
					activator = 'ring chime'
				end
				if activator
					#max_wait = Time.now + 120
					#after = table.contents.collect { |obj| obj.id }
					#while checkpcs
					#	before = after.dup
					#	100.times {
					#		sleep 0.2
					#		break unless checkpcs
					#		after = table.contents.collect { |obj| obj.id }
					#		break if before != after
					#	}
					#	break if (before == after) or (Time.now > max_wait)
					#end
					empty_hands
					for lootsack in lootsack_list
						for obj in lootsack.contents
							if obj.noun =~ /^(?:box|strongbox|chest|coffer|trunk)$/
								open_box.call(obj)
							end
						end
					end
					unless disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk$/ }
						if reget.any? { |line| line =~ /^Your disk arrives, following you dutifully\./ }
							50.times { break if GameObj.loot.any? { |obj| obj.name =~ /#{Char.name} disk$/ }; sleep 0.1 }
							disk = GameObj.loot.find { |obj| obj.name =~ /#{Char.name} disk$/ }
						end
					end
					if disk
						if GameObj.loot.any? { |obj| obj.id == disk.id }
							if disk.contents.nil?
								dothistimeout "look in ##{disk.id}", 2, /^In the|^There is nothing in there\.$/
							end
							for obj in disk.contents
								if obj.noun =~ /^(?:box|strongbox|chest|coffer|trunk)$/
									open_box.call(obj)
								end
							end
							$disk_full = false
						end
					end
					dothistimeout "drop ##{GameObj.right_hand.id}", 3, /^You drop/ if GameObj.right_hand.type =~ /box/
					dothistimeout "drop ##{GameObj.left_hand.id}", 3, /^You drop/ if GameObj.left_hand.type =~ /box/
					fill_hands
					dothistimeout "drop ##{GameObj.right_hand.id}", 3, /^You drop/ if GameObj.right_hand.type =~ /box/
					dothistimeout "drop ##{GameObj.left_hand.id}", 3, /^You drop/ if GameObj.left_hand.type =~ /box/
				else
					echo 'error: failed to find a bell, keys, or chime on the table'
				end
			else
				echo 'error: failed to find table contents'
			end
		end
	else
		echo 'error: failed to find a table'
	end
end

if CharSettings['bundle herbs'] and lootsack_list.any? { |lootsack| lootsack.contents.any? { |obj| save_herb_list.include?(obj.name) or save_one_potion_list.include?(obj.name) or save_two_potion_list.include?(obj.name) } }
	# fixme: allow lootsack and herbsack to be the same
	did_something = true
	if CharSettings['herb drop room'].nil?
		herb_drop_room = nil
	elsif CharSettings['herb drop room'] =~ /^[0-9]+$/
		herb_drop_room = CharSettings['herb drop room'].to_i
	elsif (UserVars.send(CharSettings['herb drop room']).class == Fixnum) or (UserVars.send(CharSettings['herb drop room']) =~ /^[0-9]+$/)
		herb_drop_room = UserVars.send(CharSettings['herb drop room']).to_i
	else
		echo 'warning: bad herb-drop-room setting'
		herb_drop_room = nil
	end
	check_drop_room = proc {
		unless herb_drop_room.nil? or Room.current.id == herb_drop_room
			start_script 'go2', [ herb_drop_room.to_s ]
			wait_while { running?('go2') }
		end
	}
	if herbsack.contents.nil?
		open_result = dothistimeout "open ##{herbsack.id}", 5, /^You open|^That is already open\.$/
		if open_result =~ /^You open/
			close_herbsack = true
		else
			dothistimeout "look in ##{herbsack.id}", 5, /In .*? you see/
		end
	end
	if not herbsack.contents.nil?
		empty_hands
		for lootsack in lootsack_list
			while herb_name = lootsack.contents.find { |obj| save_herb_list.include?(obj.name) }.name
				if bundle = herbsack.contents.find { |obj| obj.name == herb_name }
					dothistimeout "get ##{bundle.id}", 3, /^You remove/
				end
				drop_herb = false
				while herb = lootsack.contents.find { |obj| obj.name == herb_name }
					dothistimeout "get ##{herb.id}", 3, /^You remove/
					if drop_herb
						check_drop_room.call
						dothistimeout "drop ##{herb.id}", 3, /^You drop/
					else
						while checkleft and checkright
							bundle_result = dothistimeout 'bundle', 3, /^Carefully, you combine|^If you add anything more to this bundle|^You do not have anything to bundle!$/
							if bundle_result =~ /^If you add anything more to this bundle/
								drop_herb = true
								dothistimeout "eat ##{herb.id}", 3, /^You take a bite/
							elsif bundle_result.nil?
								break
							end
						end
					end
				end
				dothistimeout "put ##{GameObj.right_hand.id} in ##{herbsack.id}", 3, /^You put/ if checkright
				dothistimeout "put ##{GameObj.left_hand.id} in ##{herbsack.id}", 3, /^You put/ if checkleft
			end
		end
		for lootsack in lootsack_list
			while potion_name = lootsack.contents.find { |obj| save_one_potion_list.include?(obj.name) or save_two_potion_list.include?(obj.name) }.name
				drop_potion = false
				while potion = lootsack.contents.find { |obj| obj.name == potion_name }
					dothistimeout "get ##{potion.id}", 3, /^You remove/
					herbsack_potion_list = herbsack.contents.find_all { |obj| obj.name == potion_name }
					for herbsack_potion in herbsack_potion_list
						pour_result = dothistimeout "pour ##{potion.id} in ##{herbsack_potion.id}", 3, /^You carefully pour|^You can't pour any more|^I can't find that\.$|^You can't pour that\.$/
						redo if pour_result =~ /^You carefully pour/
					end
					if (GameObj.right_hand.id == potion.id) or (GameObj.left_hand.id == potion.id)
						if herbsack_potion_list.nil? or (herbsack_potion_list.length < 2 and save_two_potion_list.include?(potion_name)) or (herbsack_potion_list.length < 1 and save_one_potion_list.include?(potion_name))
							dothistimeout "put ##{potion.id} in ##{herbsack.id}", 3, /^You put/
						else
							drop_potion = true
							check_drop_room.call
							dothistimeout "drop ##{potion.id}", 3, /^You drop/
						end
					end
				end
			end
		end
		fill_hands
	else
		echo 'error: failed to find herbsack contents'
	end
	dothistimeout "close ##{herbsack.id}", 3, /^You close|^That is already closed\.$/ if close_herbsack
end

if CharSettings['chronomage'] and XMLData.game =~ /^(?:GSF|GSIV)$/
	ring_list = Array.new
	for lootsack in lootsack_list
		ring_list.concat(lootsack.contents.to_a.find_all { |obj| obj.name =~ /gold ring$/ })
	end
	unless ring_list.empty?
		did_something = true
		start_script('go2', [ 'chronomage', '--disable-confirm' ])
		wait_while { running?('go2') }
		empty_hand
		if npc = GameObj.npcs.last
			for ring in ring_list
				fput "get ##{ring.id}"
				fput 'unhide' if invisible?
				fput "give ##{ring.id} to #{npc.noun}"
				sleep 0.3
				lootsack_put.call(ring) if (GameObj.right_hand.id == ring.id) or (GameObj.left_hand.id == ring.id)
			end
		end
		fill_hand
	end
end

if CharSettings['stockpile'] and CharSettings['locker'].nil?
	echo 'warning: stockpiling is turned on but locker room is not set'
end

if CharSettings['stockpile'] and CharSettings['locker'] and (need_to_stockpile.call or need_to_raid_stockpile.call)
	did_something = true
	if to_locker.call
		stockpile.call if need_to_stockpile.call
		raid_stockpile.call if need_to_raid_stockpile.call
		from_locker.call
	end
end

for place in [ 'consignment', 'furrier', 'gemshop', 'pawnshop' ]
	sell_list = Array.new
	for lootsack in lootsack_list
		sell_list.concat(lootsack.contents.to_a.find_all { |obj| (!CharSettings['exclude regex'] or obj.name !~ /#{CharSettings['exclude regex']}/o) and (!CharSettings['exclude types'] or obj.type !~ /#{CharSettings['exclude types']}/o or $clericbot_settings['gems'].any? { |gem| gem[:id] == obj.id }) and (UserVars.needed_reagents.nil? or UserVars.needed_reagents.empty? or obj.name !~ /#{UserVars.needed_reagents}/) and !$loot_be_gone_ignore.include?(obj.id) and (obj.sellable =~ /#{place}/) })
	end
	if checkbounty =~ /gem dealer.*? (Wehnimer's Landing|Icemule Trace|Solhaven|Kharam\-Dzu|Zul Logoth|River's Rest|Ta'Illistim|Ta'Vaalor).*? requesting (?:a|an) (.*?)\. .* retrieve [0-9]+ (?:more )?of them\./
		target_town = $1
		gem = $2
		gemshop = Room[Room.current.find_nearest_by_tag('gemshop')]
		if gemshop.location and (gemshop.location =~ /Wehnimer's Landing|Icemule Trace|Solhaven|Kharam\-Dzu|Zul Logoth|River's Rest|Ta'Illistim|Ta'Vaalor/) and (gemshop.location !~ /#{target_town}/)
			sell_list.delete_if { |obj| obj.name.sub(/large |medium |small |tiny |some /, '') == gem }
		end
	end
	if checkbounty =~ /tasked to retrieve [0-9]+ (.*?) of at least .*? quality .*? (Wehnimer's Landing|Icemule Trace|Solhaven|Kharam\-Dzu|Zul Logoth|River's Rest|Ta'Illistim|Ta'Vaalor)\./
		skin = $1
		target_town = $2
		skin.sub!(/s$/, '')
		furrier = Room[Room.current.find_nearest_by_tag('furrier')]
		if furrier.location and (furrier.location =~ /Wehnimer's Landing|Icemule Trace|Solhaven|Kharam\-Dzu|Zul Logoth|River's Rest|Ta'Illistim|Ta'Vaalor/) and (furrier.location !~ /#{target_town}/)
			sell_list.delete_if { |obj| obj.name =~ /^(?:bundle of )?#{skin}\s?$/ }
		end
	end
	unless sell_list.empty?
		did_something = true
		start_script('go2', [ place, '--disable-confirm' ])
		wait_while { running?('go2') }
		empty_hands
		for obj in sell_list
			if (obj.type =~ /scroll/) and not CharSettings['keep scrolls'].empty?
				script.want_downstream = false
				script.want_downstream_xml = true
				result = dothistimeout "read ##{obj.id}", 5, /^On the/
				if result.nil?
					script.want_downstream = true
					script.want_downstream_xml = false
					echo "error: failed to read scroll"
					$loot_be_gone_ignore.push(obj.id)
					next
				end
				spell_list = Array.new
				while (line = get) and line !~ /<prompt/
					if line =~ /noun="([0-9]+)"/
						spell_list.push($1.to_i)
					end
				end
				script.want_downstream = true
				script.want_downstream_xml = false
				unless (CharSettings['keep scrolls'] & spell_list).empty?
					$loot_be_gone_ignore.push(obj.id)
					next
				end
			end
			dothistimeout "get ##{obj.id}", 2, /^You remove/
			fput 'unhide' if invisible?
			if CharSettings['appraise types'] and (obj.type =~ /#{CharSettings['appraise types']}/o) and save_value[place]
				result = dothistimeout "appraise ##{obj.id}", 5, /[0-9,]+ (?:silver|for it if you want to sell)|I'm not buying anything this valuable today|not quite my field|only deal in gems and jewelry|There is nothing of value to me|Trying to pull a fast one on old Hortemeyer, are you\?|Can't say I'm interested|That's basically worthless here/
				if result.nil? or result =~ /not quite my field|only deal in gems and jewelry|There is nothing of value to me|Trying to pull a fast one on old Hortemeyer, are you\?/
					lootsack_put.call(obj)
					next
				elsif (result =~ /([0-9,]+) (?:silver|for it if you want to sell)/ and $1.gsub(',', '').to_i >= save_value[place]) or result =~ /I'm not buying anything this valuable today|Can't say I'm interested|That's basically worthless here/
					lootsack_put.call(obj)
					$loot_be_gone_ignore.push(obj.id)
					next
				end
			end
			fput 'unhide' if invisible?
			dothistimeout "sell ##{obj.id}", 2, /(?:pays|hands) you [0-9]+ silver|not quite my field|only deal in gems and jewelry/
			if GameObj.right_hand.noun =~ /^(?:note|scrip|chit)$/
				notes.push(GameObj.right_hand.id)
				lootsack_put.call(GameObj.right_hand)
			end
			if GameObj.left_hand.noun =~ /^(?:note|scrip|chit)$/
				notes.push(GameObj.left_hand.id)
				lootsack_put.call(GameObj.left_hand)
			end
			if (GameObj.right_hand.id == obj.id) or (GameObj.left_hand.id == obj.id)
				lootsack_put.call(obj)
			end
		end
		fill_hands
	end
end

silvers = check_silvers.call
if (silvers > 0) or (notes.length > 0)
	did_something = true
	start_script 'go2', [ 'bank', '--disable-confirm' ]
	wait_while { running?('go2') }
	fput 'unhide' if invisible?
	if XMLData.room_title == '[Pinefar, Depository]'
		if silvers > 100
			dothistimeout "give banker #{silvers} silvers", 3, /takes your silvers/
		end
	else
		if silvers > 0
			dothistimeout "deposit #{silvers}", 2, /^You/
		end
	end
	for note_id in notes
		dothistimeout "get ##{note_id}", 2, /^You/
		fput 'unhide' if invisible?
		if XMLData.room_title == '[Pinefar, Depository]'
			dothistimeout "give ##{note_id} to banker", 2, /^takes your note|laughs at you/
		else
			dothistimeout "deposit ##{note_id}", 2, /^You/
		end
		if (GameObj.right_hand.id == note_id) or (GameObj.left_hand.id == note_id)
			lootsack_put.call(note_id)
		end
	end
end

for lootsack_id in need_close_lootsack
	dothistimeout "close ##{lootsack_id}", 3, /^You close|^That is already closed;\./
end

if did_something
	echo 'done'
else
	echo 'nothing to do'
end

# fixme: There is no merchant here that can buy that
# fixme: The glass jar does not appear to be a suitable container for a black helmet shell.
